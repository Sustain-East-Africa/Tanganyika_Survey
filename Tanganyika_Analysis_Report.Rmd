---
title: "Baseline Study for the Lake Tanganyika Programme"
subtitle: "Household Socioeconomic Assessment"
author: 
  - "Sustain East Africa"
date: "November 2024"
output: 
  sea::sea_paged:
    draft_watermark: false
    remove_footer_title: true
    number_sections: false
    front_cover:
      - "img/lake_tanganyika_AI.webp"
bibliography: references.bib  
biblio-style: "apalike"
nocite: '@*'
toc-title: "Table of Contents"
lof: true
lot: true
lof-unlisted: true
lot-unlisted: true
knit: pagedown::chrome_print
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)
```

```{r library and load df}
library(sea)
library(tidyverse)
library(xfun)
library(lubridate)
library(openxlsx)
library(scales)
library(googlesheets4)
library(stats)
library(stats4)
library(survey)
library(srvyr, warn.conflicts = FALSE)
library(cowplot)
library(egg)
library(tibble)
library(fontawesome)
library(mapview)
library(sf)
library(dplyr)
library(readxl)
library(readr)
library(leaflet)
library(tidyr)
library(flextable)
library(viridis)

#Sustain EA colour palette
SEA_palette <- c("#d77e5e", "#a4b792", "#e6e7e2", "#3d5919", "#202C39", "#381D2A", "#000000",
                 "#f2a084", "#b9c9b1", "#f0f1ed", "#5b7a2e", "#404b58", "#522a3b", "#1a1a1a", 
                 "#b15e42", "#839c7a", "#d2d2c8", "#293c14", "#151d29", "#2a171e", "#3c3c3c")

# Load data
tanganyika_clean <- readRDS("LTP_Baseline_2024_Clean.rds")
demo <- readRDS("survey_demo.rds")

# Set survey design
tanganyika_survey <- tanganyika_clean %>%
    as_survey_design(strata = stype, fpc = fpc)

# Create village clusters for plotting
cluster_1_villages <- c("Izinga", "Kala", "Katenge", "Kilambo cha Mkolechi", 
                        "Kizumbi", "Lyapinda", "Mpasa", "Mwinza", "Ng'anga", 
                        "Tundu", "Wampembe", "Overall North")
cluster_2_villages <- c("Isasa", "Kalungu", "Kichangani", "Kipili", 
                        "Majengo Mapya", "Manda Kerenge", "Manda Uhuru", 
                        "Mkinga", "Mtakuja", "Ntanganyika", "Overall South", "Overall")
```

\newpage

### Disclaimer

Disclaimer

### Rights

Rights

### Suggested citation

Please cite this report as such :

### Acknowledgements

Acknowledgements

<!-- inverse gunmetal page -->

::: {.section-gunmetal-inverse}
# Summary

Provide broad overview of survey and key findings.
:::

<!-- inverse rust page -->

::: {.section-rust-inverse}
# Introduction

1. Background of the Survey

Lake Tanganyika, the world's second-deepest lake and one of the oldest, is a biodiversity
hotspot and a vital freshwater source for the region. Its shores teem with unique flora and
fauna, sustaining both aquatic life and the communities living nearby. However, the lake
and its environs confront various challenges endangering this delicate balance. Population
growth, unsustainable fishing, deforestation, waste mismanagement, and limited access to
services threaten the ecosystem and community well-being.
The Lake Tanganyika Program (LTP) was initiated by building from experience with other fishing communities along the Tanzanian lakeshore and acknowledging the pressing need to tackle these challenges while envisioning a harmonious coexistence between communities and nature. Through collaboration and innovative approaches, LTP aims to establish and support a regional network of community-based co-managed fisheries areas and empower communities to locally co-manage their fisheries, enhance fish value chains,
improve livelihoods, and support conservation efforts.
Measuring the program's impact over time is crucial for ensuring effectiveness and
sustainability and thus the purpose of the survey. This requires understanding local
contexts, identifying challenges, and devising strategies for lasting development.

2. Purpose of the Survey

The main objective of the survey was to measure the impact brought about by the Lake
Tanganyika program over time, and assess the existing conditions, identify challenges, and
eventually formulate strategies for sustainable development.

3. Coverage

The survey is intended to cover out in Kirando, Itete, Kipili, Mkinga Ward, Kala,
Wampembe or Kizumbi? wards (kata), in the following 21 villages (vijiji): Kichangani,
Mtakuja, Isasa, Kipili, Manda Kerenge, Mkinga, Ntanganyika, Kalungu, Manda Uhuru,
Majengo Mapya,Mpasa, Kilambo cha Mkolechi, Tundu, Kala, Wampembe, Mwinza, Izinga,
Lyapinda, Kizumbi, Katenge, Ng'anga.

## Enumerator Training
Training was crucial for enumerators before they began the household surveys to ensure that data collection is accurate, consistent, and ethical. The training covered essential responsibilities, including understanding the code of conduct, managing interview confidentiality, handling incomplete or uncertain responses, and reviewing the questionnaire at the end of each interview.
Enumerators also learnt about their roles in relation to supervisors, debriefing sessions, and data entry. Through detailed discussions of the survey's sections—ranging from household information to livelihood practices—the enumerators gained a thorough understanding of the questionnaire. Additionally, hands-on training in using tablets and survey software, combined with testing the questions among themselves and a pilot study, prepares them for real-world challenges, ensuring they can manage their workload and accurately capture the data needed.


## Pilot Study
The pilot study was conducted over two days, on October 10th and 11th, with a total of 43
questionnaires finalized and submitted to the server. This study provided a platform to
refine all pending errors and issues, which were resolved before the main survey began on
Saturday, October 12th, 2024.
Some of the issues raised, particularly regarding the hard copy questionnaire and the Open
Data Kit (ODK) survey form, were addressed during the supervisor-enumerator training.
Below are examples of some of the issues that were raised.
:::

<!-- rust page -->

::: {.section-rust}

## Methodology and Sampling

### Sampling Design

The study population was defined as those households currently living within the two village clusters, which comprise the 21 villages along the Lake Tanganyika shoreline.
A stratified random sampling design was employed across the study population. Stratified sampling involved dividing the study population strata (villages) and drawing separate probability samples from each stratum. Stratification ensures that a pre-specified number of observations from each stratum end up in the sample, which is therefore less variable, yet may provide more precise estimates to adequately represent the entire population.
The strata in this study were defined based on household locations and represent the different villages. By dividing the population into strata, the sampling design aims to capture the variability within these groups and ensure that each important subgroup is well-represented in the final sample. The sampling frame for the stratified design represents the total list of households within the two clusters of villages. A finite population correction (FPC), is applied to reduce the variance of estimates, which accounts for the fact that sampling a substantial proportion of households in each stratum may lead to a decrease in variability. As such, the FPC is incorporated into the weighting of final survey estimates to correct for finite population size. The stratified sampling design ensures that each stratum is adequately represented and reduces variability within the sample, leading to more accurate conclusions and better-informed policy recommendations.


<!-- ```{r} -->
<!-- # Data -->
<!-- data <- data.frame( -->
<!--   Variables = c("Population", "Proportion of population", "Sample", "Proportion of sample", "Final sample number"), -->
<!--   `Kichangani` = c(325, 0.09323006311, 46.61503155, 0.09323006311, 47), -->
<!--   `Mtakuja` = c(364, 0.1044176707, 52.20883534, 0.1044176707, 52), -->
<!--   `Mkinga` = c(325, 0.09323006311, 46.61503155, 0.09323006311, 47), -->
<!--   `Majengo Mapya` = c(210, 0.06024096386, 30.12048193, 0.06024096386, 30), -->
<!--   `Manda Uhuru` = c(147, 0.0421686747, 21.08433735, 0.0421686747, 21), -->
<!--   `Kalungu` = c(566, 0.1623637407, 81.18187034, 0.1623637407, 81), -->
<!--   `Ntanganyika` = c(229, 0.06569133678, 32.84566839, 0.06569133678, 33), -->
<!--   `Isasa` = c(281, 0.08060814687, 40.30407344, 0.08060814687, 40), -->
<!--   `Kipili` = c(383, 0.1098680436, 54.9340218, 0.1098680436, 55), -->
<!--   `Manda Kerenge` = c(656, 0.1881812966, 94.09064831, 0.1881812966, 94), -->
<!--   Total = c(3486, 1, 500, 0.1434308663, 500) -->
<!-- ) -->

<!-- # Rename columns to preserve spacing -->
<!-- colnames(data) <- gsub("\\.", " ", colnames(data)) -->

<!-- # Round values based on conditions -->
<!-- data_formatted <- data %>% -->
<!--   mutate(across( -->
<!--     where(is.numeric), -->
<!--     ~ ifelse(Variables %in% c("Population", "Sample", "Final sample number"), round(.), round(., 3)) -->
<!--   )) -->

<!-- # Create and style flextable -->
<!-- add_lot_link(caption = 'Cluster 1 sampling design for households along Lake Tanganyika') -->

<!-- data_formatted %>% -->
<!--   sea::sea_table( -->
<!--     dark_color = sea_colors("gunmetal"), -->
<!--     pale_color = sea_colors("grey"), -->
<!--     third_color = "white") %>% -->
<!--   colformat_double( -->
<!--     j = 2:ncol(data_formatted), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   colformat_double( -->
<!--     j = 2:ncol(data_formatted), -->
<!--     i = which(data_formatted$Variables %in% c("Population", "Sample", "Final sample number")), -->
<!--     digits = 0 -->
<!--   ) %>% -->
<!--   autofit() -->

<!-- ``` -->


<!-- ```{r} -->
<!-- # Data -->
<!-- data <- data.frame( -->
<!--   Variables = c("Population", "Proportion of population", "Sample", "Proportion of sample", "Final sample number"), -->
<!--   `Kala` = c(358, 0.07631635046, 38.15817523, 0.07631635046, 38), -->
<!--   `Mpasa` = c(795, 0.1694734598, 84.73672991, 0.1694734598, 85), -->
<!--   `Kilambo cha Mkolechi` = c(344, 0.07333191217, 36.66595609, 0.07333191217, 37), -->
<!--   `Tundu` = c(301, 0.06416542315, 32.08271158, 0.06416542315, 32), -->
<!--   `Wampembe` = c(802, 0.170965679, 85.48283948, 0.170965679, 86), -->
<!--   `Mwinza` = c(356, 0.07589000213, 37.94500107, 0.07589000213, 38), -->
<!--   `Izinga` = c(527, 0.1123427841, 56.17139203, 0.1123427841, 56), -->
<!--   `Kizumbi` = c(293, 0.06246002984, 31.23001492, 0.06246002984, 31), -->
<!--   `Lyapinda` = c(600, 0.127904498, 63.95224899, 0.127904498, 64), -->
<!--   `Ng'anga` = c(172, 0.03666595609, 18.33297804, 0.03666595609, 18), -->
<!--   `Katenge` = c(143, 0.03048390535, 15.24195268, 0.03048390535, 15), -->
<!--   Total = c(4691, 1, 500, 0.1065870816, 500) -->
<!-- ) -->

<!-- # Rename columns to preserve spacing -->
<!-- colnames(data) <- gsub("\\.", " ", colnames(data)) -->

<!-- # Round values based on conditions -->
<!-- data_formatted <- data %>% -->
<!--   mutate(across( -->
<!--     where(is.numeric), -->
<!--     ~ ifelse(Variables %in% c("Population", "Sample", "Final sample number"), round(.), round(., 3)) -->
<!--   )) -->

<!-- # Create and style flextable -->
<!-- add_lot_link(caption = 'Cluster 2 sampling design for households along Lake Tanganyika') -->

<!-- data_formatted %>% -->
<!--   sea::sea_table( -->
<!--     dark_color = sea_colors("gunmetal"), -->
<!--     pale_color = sea_colors("grey"), -->
<!--     third_color = "white") %>% -->
<!--   colformat_double( -->
<!--     j = 2:ncol(data_formatted), -->
<!--     digits = 3 -->
<!--   ) %>% -->
<!--   colformat_double( -->
<!--     j = 2:ncol(data_formatted), -->
<!--     i = which(data_formatted$Variables %in% c("Population", "Sample", "Final sample number")), -->
<!--     digits = 0 -->
<!--   ) %>% -->
<!--   autofit() -->

<!-- ``` -->



::: 

<!-- rust page -->
<div class ="section-rust">

<!-- columns layout -->
<!-- article instead of a div if you have titles to should go in the TOC -->

## General Household Information

This study uses a common definition of what constitutes a household: a group of people who live and usually share their food together. This is not the same as a family. A family includes only people who are related, but a household includes any people who live together, whether they are related or not. The survey found that almost all household members were related, either through blood or marriage, to the household head. The survey sampled 996 households distributed across 21 villages (Table 1). 

```{r}
population_data <- tibble::tribble(
  ~village, ~population,
  "Kichangani", 325,
  "Mtakuja", 364,
  "Mkinga", 325,
  "Majengo Mapya", 210,
  "Manda Uhuru", 147,
  "Kalungu", 566,
  "Ntanganyika", 229,
  "Isasa", 281,
  "Kipili", 383,
  "Manda Kerenge", 656,
  "Kala", 358,
  "Mpasa", 795,
  "Kilambo cha Mkolechi", 344,
  "Tundu", 301,
  "Wampembe", 826,
  "Mwinza", 356,
  "Izinga", 527,
  "Kizumbi", 293,
  "Lyapinda", 600,
  "Ng'anga", 172,
  "Katenge", 143)

# Summarize data by village
sampling_overview <- tanganyika_survey %>%
  group_by(village) %>%
  summarise(
    sampled_households = n_distinct(hh_code, na.rm = TRUE),
    num_fishers = sum(main_activity == "FISHER", na.rm = TRUE),
    num_women = sum(sex == "FEMALE", na.rm = TRUE)
  ) %>%
  ungroup() %>%
  left_join(population_data, by = "village")

# Add a totals row
sampling_overview <- sampling_overview %>%
  bind_rows(
    summarise(
      .,
      village = "Overall",
      population = sum(population, na.rm = TRUE),
      sampled_households = sum(sampled_households, na.rm = TRUE),
      num_fishers = sum(num_fishers, na.rm = TRUE),
      num_women = sum(num_women, na.rm = TRUE)))

# Reorder columns to place population after village
sampling_overview <- sampling_overview %>%
  select(village, population, everything())

# Create and style flextable
add_lot_link(caption = 'Sample overview')

# Create a flextable from the summary dataframe
sampling_overview %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white") %>%
  set_header_labels(
    village = "Village",
    population = "Population",
    sampled_households = "Sampled Households",
    num_fishers = "Number of Fishers Interviewed",
    num_women = "Number of Women Interviewed") %>%
  autofit()
```



```{r, fig.cap='Map of lake Tanganyika with sample sizes from each locations', fig.align='center', out.width = '70%'}
knitr::include_graphics('img/village_sample_size_map.png')
```


Population Pyramid

Nearly half (45.5%) the population of the households surveyed was under the age of 15 (Figure 2). This is comparable to the national average of 46% (2022 TDHSMIS). Most of the other half of the Lake Tanganyika population is between 15 and 64 (52.2%); people aged 65 and older only make up 2.3% of the population. 

```{r, fig.cap='Population pyramid', fig.align='center', out.width = '70%'}
age_levels <- c("<5", "5-9", "10-14", "15-19", "20-24", "25-29", "30-34",
                "35-39", "40-44", "45-49", "50-54", "55-59", "60-64",
                "65-69", "70-74", "75-79", "80+")

# Categorize age groups and ensure they have the correct order
demo <- demo %>%
  mutate(age_group = case_when(
    age >= 80 ~ "80+",
    age >= 75 & age < 80 ~ "75-79",
    age >= 70 & age < 75 ~ "70-74",
    age >= 65 & age < 70 ~ "65-69",
    age >= 60 & age < 65 ~ "60-64",
    age >= 55 & age < 60 ~ "55-59",
    age >= 50 & age < 55 ~ "50-54",
    age >= 45 & age < 50 ~ "45-49",
    age >= 40 & age < 45 ~ "40-44",
    age >= 35 & age < 40 ~ "35-39",
    age >= 30 & age < 35 ~ "30-34",
    age >= 25 & age < 30 ~ "25-29",
    age >= 20 & age < 25 ~ "20-24",
    age >= 15 & age < 20 ~ "15-19",
    age >= 10 & age < 15 ~ "10-14",
    age >= 5 & age < 10 ~ "5-9",
    age < 5 ~ "<5"
  )) %>%
  mutate(age_group = factor(age_group, levels = age_levels))  # Set factor levels for ordering

# Calculate overall percentages by age group and gender, excluding unwanted sex value
total_count <- nrow(demo %>% filter(sex != "I DO NOT WANT TO ANSWER"))  # Total population count for reference

demo_summary <- demo %>%
  filter(sex != "I DO NOT WANT TO ANSWER") %>%
  count(age_group, sex) %>%
  mutate(percentage = n / total_count * 100)  # Calculate percentage of entire population

# Plot population pyramid
ggplot(demo_summary, aes(x = age_group, y = ifelse(sex == "MALE", -percentage, percentage), fill = sex)) +
  geom_bar(stat = "identity", width = 0.8) +
  coord_flip() +
  scale_y_continuous(labels = function(x) paste0(abs(x), "%"), limits = c(-10, 10)) +
  labs(x = "Age Group", y = "Percentage of Total Population") +
  scale_fill_viridis(discrete = TRUE, option = "D",labels = c("FEMALE" = "Female", "MALE" = "Male")) +
  sea::theme_sea()+
  theme(legend.title = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  geom_text(aes(label = paste0(round(abs(percentage), 1), "%")), 
            position = position_nudge(x = 0, y = ifelse(demo_summary$sex == "MALE", -1, 1)), 
            size = 3, 
            color = "black")

```

The average household size in this survey was 5.2 (Table 2). This is smaller than the 6.7 members found in the 2011 Tuungane survey but higher than the 2022 national average of 4.5 household members (2022 TDHSMIS). Female household heads make up 22% of the sample, which is higher than the findings from the 2011 Tuungane survey but still lower than the national average of 29% (2022 TDHSMIS).

```{r}
current_survey <- tanganyika_survey %>%
  summarise(
    avg_household_size = mean(hh_members, na.rm = TRUE),
    prop_female_headed = mean(sex == "FEMALE", na.rm = TRUE) * 100
  )

# Define data for other surveys
other_surveys <- tibble::tibble(
  Survey = c("2011 Tuungane Survey", "2006 Mahale Survey", "2010 DHS"),
  Mean_Household_Size = c(6.7, 6.6, 5.2),
  Proportion_Female_Headed = c(16, 12, 25)
)

# Combine all surveys into one table
summary_table <- tibble::tibble(
  Survey = "Current Survey",
  Mean_Household_Size = round(current_survey$avg_household_size, 1),
  Proportion_Female_Headed = round(current_survey$prop_female_headed, 0)
) %>%
  bind_rows(other_surveys)

# Create and style flextable
add_lot_link(caption = 'Mean household size and female household heads')

# Create a flextable
summary_table %>%
   sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white") %>%
  set_header_labels(
    Survey = "Survey",
    Mean_Household_Size = "Mean household size",
    Proportion_Female_Headed = "Proportion of female headed households (%)") %>%
  autofit()
```

Only 17% of female household heads are married, compared to 78% for all heads. The majority of female household heads are either widowed (45%) or divorced or separated (32%) (Table 3).

Farming is the typical main activity among household heads (48%). Many household heads (43%) also engage in fish-based livelihood activities (fishing, fish trading, and fish processing).

```{r}
# Calculate marital status proportions
marital_status_summary <- tanganyika_survey %>%
  filter(!is.na(marital_status)) %>%
  group_by(marital_status) %>%
  summarise(
    all_count = n(),
    female_count = sum(sex == "FEMALE", na.rm = TRUE)) %>%
  mutate(
    all_percent = round(100 * all_count / sum(all_count), 0),
    female_percent = round(100 * female_count / sum(female_count), 0))

# Calculate main activity proportions
main_activity_summary <- tanganyika_survey %>%
  filter(!is.na(main_activity)) %>%
  group_by(main_activity) %>%
  summarise(
    all_count = n(),
    female_count = sum(sex == "FEMALE", na.rm = TRUE)) %>%
  mutate(
    all_percent = round(100 * all_count / sum(all_count), 0),
    female_percent = round(100 * female_count / sum(female_count), 0))

# Add totals row for marital status
marital_status_summary <- marital_status_summary %>%
  bind_rows(
    summarise(
      .,
      marital_status = "Overall (%)",
      all_percent = 100,
      female_percent = 100)) %>%
  bind_rows(
    tibble(
      marital_status = "n",
      all_percent = sum(marital_status_summary$all_count, na.rm = TRUE),
      female_percent = sum(marital_status_summary$female_count, na.rm = TRUE)))

# Add totals row for main activity
main_activity_summary <- main_activity_summary %>%
  bind_rows(
    summarise(
      .,
      main_activity = "Overall (%)",
      all_percent = 100,
      female_percent = 100)) %>%
  bind_rows(
    tibble(
      main_activity = "n",
      all_percent = sum(main_activity_summary$all_count, na.rm = TRUE),
      female_percent = sum(main_activity_summary$female_count, na.rm = TRUE)))

# Combine marital status and main activity summaries
combined_table <- bind_rows(
  marital_status_summary %>%
    rename(Category = marital_status),
  main_activity_summary %>%
    rename(Category = main_activity))

# Format the Category column to lowercase with first letter uppercase
combined_table <- combined_table %>%
  mutate(Category = str_to_title(Category)) %>%
  select(Category, all_percent, female_percent)

# Create and style flextable
add_lot_link(caption = 'Marital status and main activities of household heads')

# Create flextable
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white") %>%
  set_header_labels(
    Group = " ",
    Category = "Category",
    all_percent = "All Household Heads (%)",
    female_percent = "Female Household Heads (%)") %>% autofit()


```

Overall, 30% of the household heads were born in the village where they lived at the time of the survey (Table 4). Kala and Mwinza stand out as less than 15% of resident household heads were born in those two villages. On average, household heads spent 22 years living in their village if they weren’t born there. This suggests that there has not been a high level of recent migration to the villages sampled in recent years.

```{r}
# Summarize the data by village and born_ward
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(born_ward) & born_ward != "I DON'T KNOW") %>% 
  group_by(village, born_ward) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
proportion_table <- summary_by_village %>%
  select(village, born_ward, proportion) %>%
  pivot_wider(
    names_from = born_ward,    # Use `born_ward` values as column names
    values_from = proportion   # Fill with the proportion values
  )

# Rename columns for clarity
colnames(proportion_table) <- c("village", "Yes (%)", "No")

# Format the proportion table values as percentages with one decimal point and add % sign
proportion_table <- proportion_table %>%
  mutate(across(c("Yes (%)", "No"), ~ paste0(round(. * 100, 0))))

# Create a separate table to calculate the average years lived in the village by respondents who answered "No"
years_lived_table <- tanganyika_clean %>%
  filter(born_ward == "NO" & !is.na(years_lived) & years_lived > 0) %>%  # Filter "No" responses and valid years_lived data
  group_by(village) %>%
  summarise(avg_years_lived = mean(years_lived, na.rm = TRUE)) %>%
  ungroup()

# Format the years lived table to one decimal point
years_lived_table <- years_lived_table %>%
  mutate(avg_years_lived = round(avg_years_lived, 0))

combined_table <- proportion_table %>%
  left_join(years_lived_table, by = "village") %>%
  select(Village = village, `Yes (%)`, `Average years spent if not born` = avg_years_lived)

# Rename columns for clarity
colnames(combined_table) <- c("Village", "Yes (%)", "Average years spent if not born")

total_row <- combined_table %>%
  summarise(
    Village = "Overall",
    `Yes (%)` = mean(as.numeric(sub("%", "", `Yes (%)`)) / 100, na.rm = TRUE) * 100,
    `Average years spent if not born` = mean(`Average years spent if not born`, na.rm = TRUE)) %>%
  mutate(
    `Yes (%)` = paste0(round(`Yes (%)`, 0)),
    `Average years spent if not born` = round(`Average years spent if not born`, 0))

# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)

add_lot_link(caption = 'Proportion of household heads born in the ward')

# Create the flextable for the combined table
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()  # Automatically adjust column widths

```

\newpage

### Poverty Probability Index

The Poverty Probability Index (PPI) is a country-specific poverty measurement tool. Responses to ten simple questions are scored to estimate the probability that a household is poor. The PPI uses an algorithm that processes data that has already been collected by large, nationally representative household surveys to determine both the set of questions that are most informative, and the points attached to each response. The construction of each country-specific PPI has been derived from each country’s Statistics Office representative expenditure/income survey.
A household is defined as poor, with reference to a poverty line, if its consumption expenditure/consumption/income, adjusted for household size, is below that poverty line. A poverty line is determined based on the cost of consuming a basket of goods and services consistent with a given standard of living.

Overall, 64% of households in the survey live below the upper national poverty line. 26% of households live below the extreme poverty line. 

```{r}
# Ensure the age column is numeric for filtering youths
survey_data <- tanganyika_clean %>%
  mutate(hh_members = as.numeric(hh_members))

# Define energy_source column and add in Rukwa region column
survey_data <- survey_data %>%
  mutate(
    energy_source = case_when(
      solar_panel == "YES" | generator == "YES" ~ "solar or generator",
      tanesco_power == "YES" ~ "electricity", TRUE ~ "other"), region = "Rukwa")

# Columns of interest
columns_of_interest <- c("region", "hh_members", "beef", "milk", "rice", "flour", "wall_material", "energy_source", "iron","table")

# Define the PPI scorecard
upper_ppi_scorecard <- list(
  region = c("Rukwa" = 2),
  hh_members = c("1" = 32, "2" =32, "3" = 32, "4" = 10, "5" = 10, "6" = 10, "7" = 0, "8" = 0, "9" = 0, "10" = 0, "11" = 0, "12" = 0, "13" = 0, "14" = 0),
  beef = c("Yes" = 7, "No" = 0),
  milk = c("Yes" = 7, "No" = 0),
  rice = c("Yes" = 6, "No" = 0),
  flour = c("Yes" = 7, "No" = 0),
  wall_material = c("BAKED BRICKS" = 0, "GRASS/REEDS" =0, "CEMENT BRICKS" = 2, "SUNDRIED BRICKS" = 0, "POLES AND MUD" = 0, "IRON SHEETS" = 0,  "STONES" =2),
  energy_source = c("electricity" = 11, "solar or generator" = 3, "other" = 0),
  iron = c("Yes" = 10, "No" = 0),
  table = c("Yes" = 3, "No" = 0)
)

lower_ppi_scorecard <- list(
  region = c("Rukwa" = 2),
  hh_members = c("1" = 27, "2" =27, "3" = 27, "4" = 10, "5" = 10, "6" = 10, "7" = 0, "8" = 0, "9" = 0, "10" = 0, "11" = 0, "12" = 0, "13" = 0, "14" = 0),
  beef = c("Yes" = 8, "No" = 0),
  milk = c("Yes" = 8, "No" = 0),
  rice = c("Yes" = 7, "No" = 0),
  flour = c("Yes" = 8, "No" = 0),
  wall_material = c("BAKED BRICKS" = 0, "GRASS/REEDS" =0, "CEMENT BRICKS" = 2, "SUNDRIED BRICKS" = 0, "POLES AND MUD" = 0, "IRON SHEETS" = 0,  "STONES" =2),
  energy_source = c("electricity" = 11, "solar or generator" = 4, "other" = 0),
  iron = c("Yes" = 9, "No" = 0),
  table = c("Yes" = 4, "No" = 0))

extreme_ppi_scorecard <- list(
  region = c("Rukwa" = 3),
  hh_members = c("1" = 22, "2" =22, "3" = 22, "4" = 9, "5" = 9, "6" = 9, "7" = 0, "8" = 0, "9" = 0, "10" = 0, "11" = 0, "12" = 0, "13" = 0, "14" = 0),
  beef = c("Yes" = 9, "No" = 0),
  milk = c("Yes" = 7, "No" = 0),
  rice = c("Yes" = 8, "No" = 0),
  flour = c("Yes" = 9, "No" = 0),
  wall_material = c("BAKED BRICKS" = 0, "GRASS/REEDS" =0, "CEMENT BRICKS" = 0, "SUNDRIED BRICKS" = 0, "POLES AND MUD" = 0, "IRON SHEETS" = 0,  "STONES" =0),
  energy_source = c("electricity" = 9, "solar or generator" = 6, "other" = 0),
  iron = c("Yes" = 11, "No" = 0),
  table = c("Yes" = 6, "No" = 0))

# Function to compute PPI score for a single row
compute_ppi_score <- function(row, scorecard) {
  score <- 0
  for (col in names(scorecard)) {
    response <- as.character(row[[col]])
    if (!is.na(response) && response %in% names(scorecard[[col]])) {
      score <- score + scorecard[[col]][response]
    }
  }
  return(score)
}

# Add PPI scores to the survey data
survey_data <- survey_data %>%
  rowwise() %>%
  mutate(upper_PPI_Score = compute_ppi_score(cur_data(), upper_ppi_scorecard))
survey_data <- survey_data %>%
  rowwise() %>%
  mutate(lower_PPI_Score = compute_ppi_score(cur_data(), lower_ppi_scorecard))
survey_data <- survey_data %>%
  rowwise() %>%
  mutate(extreme_PPI_Score = compute_ppi_score(cur_data(), extreme_ppi_scorecard))

# 2018 Tanzania PPI Look-Up Table – Upper National Poverty Line
upper_lookup_table <- list(
  "0" = 88.6, "1" = 87.8, "2" = 86.9, "3" = 86.0, "4" = 85.0,
  "5" = 83.9, "6" = 82.8, "7" = 81.7, "8" = 80.4, "9" = 79.2,
  "10" = 77.8, "11" = 76.4, "12" = 75.0, "13" = 73.4, "14" = 71.9,
  "15" = 70.2, "16" = 68.6, "17" = 66.8, "18" = 65.0, "19" = 63.2,
  "20" = 61.3, "21" = 59.4, "22" = 57.5, "23" = 55.6, "24" = 53.6,
  "25" = 51.6, "26" = 49.6, "27" = 47.6, "28" = 45.7, "29" = 43.7,
  "30" = 41.8, "31" = 39.8, "32" = 38.0, "33" = 36.1, "34" = 34.3,
  "35" = 32.5, "36" = 30.8, "37" = 29.1, "38" = 27.5, "39" = 26.0,
  "40" = 24.5, "41" = 23.0, "42" = 21.7, "43" = 20.3, "44" = 19.1,
  "45" = 17.9, "46" = 16.7, "47" = 15.7, "48" = 14.7, "49" = 13.7,
  "50" = 12.8, "51" = 11.9, "52" = 11.1, "53" = 10.3, "54" = 9.6,
  "55" = 9.0, "56" = 8.3, "57" = 7.7, "58" = 7.2, "59" = 6.7,
  "60" = 6.2, "61" = 5.8, "62" = 5.3, "63" = 5.0, "64" = 4.6,
  "65" = 4.3, "66" = 3.9, "67" = 3.7, "68" = 3.4, "69" = 3.1,
  "70" = 2.9, "71" = 2.7, "72" = 2.5, "73" = 2.3, "74" = 2.1,
  "75" = 2.0, "76" = 1.8, "77" = 1.7, "78" = 1.6, "79" = 1.4,
  "80" = 1.3, "81" = 1.2, "82" = 1.1, "83" = 1.1, "84" = 1.0,
  "85" = 0.9, "86" = 0.8, "87" = 0.8, "88" = 0.7, "89" = 0.7,
  "90" = 0.6, "91" = 0.6, "92" = 0.5, "93" = 0.5, "94" = 0.4,
  "95" = 0.4, "96" = 0.4, "97" = 0.3, "98" = 0.3, "99" = 0.3,
  "100" = 0.3)

# 2018 Tanzania PPI Look-Up Table – Lower National Poverty Line
lower_lookup_table <- list(
  "0" = 86.3, "1" = 85.3, "2" = 84.2, "3" = 83.0, "4" = 81.8,
  "5" = 80.5, "6" = 79.1, "7" = 77.7, "8" = 76.2, "9" = 74.6,
  "10" = 73.0, "11" = 71.3, "12" = 69.6, "13" = 67.8, "14" = 65.9,
  "15" = 64.0, "16" = 62.0, "17" = 60.0, "18" = 57.9, "19" = 55.9,
  "20" = 53.8, "21" = 51.7, "22" = 49.6, "23" = 47.5, "24" = 45.4,
  "25" = 43.3, "26" = 41.2, "27" = 39.2, "28" = 37.2, "29" = 35.3,
  "30" = 33.4, "31" = 31.5, "32" = 29.7, "33" = 28.0, "34" = 26.3,
  "35" = 24.7, "36" = 23.2, "37" = 21.7, "38" = 20.3, "39" = 19.0,
  "40" = 17.7, "41" = 16.5, "42" = 15.4, "43" = 14.3, "44" = 13.3,
  "45" = 12.4, "46" = 11.5, "47" = 10.7, "48" = 9.9, "49" = 9.2,
  "50" = 8.5, "51" = 7.8, "52" = 7.3, "53" = 6.7, "54" = 6.2,
  "55" = 5.7, "56" = 5.3, "57" = 4.9, "58" = 4.5, "59" = 4.2,
  "60" = 3.8, "61" = 3.5, "62" = 3.3, "63" = 3.0, "64" = 2.8,
  "65" = 2.5, "66" = 2.3, "67" = 2.2, "68" = 2.0, "69" = 1.8,
  "70" = 1.7, "71" = 1.6, "72" = 1.4, "73" = 1.3, "74" = 1.2,
  "75" = 1.1, "76" = 1.0, "77" = 0.9, "78" = 0.9, "79" = 0.8,
  "80" = 0.7, "81" = 0.7, "82" = 0.6, "83" = 0.6, "84" = 0.5,
  "85" = 0.5, "86" = 0.4, "87" = 0.4, "88" = 0.4, "89" = 0.3,
  "90" = 0.3, "91" = 0.3, "92" = 0.3, "93" = 0.2, "94" = 0.2,
  "95" = 0.2, "96" = 0.2, "97" = 0.2, "98" = 0.2, "99" = 0.1,
  "100" = 0.1)

# 2018 Tanzania PPI Look-Up Table – Extreme National Poverty Line
extreme_lookup_table <- list(
  "0" = 63.0, "1" = 60.7, "2" = 58.4, "3" = 56.1, "4" = 53.8,
  "5" = 51.4, "6" = 49.0, "7" = 46.6, "8" = 44.3, "9" = 41.9,
  "10" = 39.6, "11" = 37.4, "12" = 35.2, "13" = 33.0, "14" = 31.0,
  "15" = 29.0, "16" = 27.0, "17" = 25.2, "18" = 23.4, "19" = 21.8,
  "20" = 20.2, "21" = 18.7, "22" = 17.3, "23" = 16.0, "24" = 14.7,
  "25" = 13.6, "26" = 12.5, "27" = 11.5, "28" = 10.6, "29" = 9.7,
  "30" = 8.9, "31" = 8.2, "32" = 7.5, "33" = 6.8, "34" = 6.3,
  "35" = 5.7, "36" = 5.2, "37" = 4.8, "38" = 4.4, "39" = 4.0,
  "40" = 3.6, "41" = 3.3, "42" = 3.0, "43" = 2.8, "44" = 2.5,
  "45" = 2.3, "46" = 2.1, "47" = 1.9, "48" = 1.7, "49" = 1.6,
  "50" = 1.4, "51" = 1.3, "52" = 1.2, "53" = 1.1, "54" = 1.0,
  "55" = 0.9, "56" = 0.8, "57" = 0.7, "58" = 0.7, "59" = 0.6,
  "60" = 0.6, "61" = 0.5, "62" = 0.5, "63" = 0.4, "64" = 0.4,
  "65" = 0.3, "66" = 0.3, "67" = 0.3, "68" = 0.3, "69" = 0.2,
  "70" = 0.2, "71" = 0.2, "72" = 0.2, "73" = 0.2, "74" = 0.1,
  "75" = 0.1, "76" = 0.1, "77" = 0.1, "78" = 0.1, "79" = 0.1,
  "80" = 0.1, "81" = 0.1, "82" = 0.1, "83" = 0.1, "84" = 0.1,
  "85" = 0.1, "86" = 0.0, "87" = 0.0, "88" = 0.0, "89" = 0.0,
  "90" = 0.0, "91" = 0.0, "92" = 0.0, "93" = 0.0, "94" = 0.0,
  "95" = 0.0, "96" = 0.0, "97" = 0.0, "98" = 0.0, "99" = 0.0,
  "100" = 0.0)


# Function to compute the average poverty likelihood for a group
compute_poverty_likelihood <- function(ppi_scores, lookup_table) {
  poverty_likelihoods <- sapply(ppi_scores, function(score) {
    if (is.null(lookup_table[as.character(score)])) {
      return(NA)  # Handle unmatched scores
    }
    return(lookup_table[[as.character(score)]])
  })
  return(mean(as.numeric(poverty_likelihoods), na.rm = TRUE))
}

# Compute PPI score for the overall survey group
upper_overall_poverty_likelihood <- compute_poverty_likelihood(survey_data$upper_PPI_Score, upper_lookup_table)
lower_overall_poverty_likelihood <- compute_poverty_likelihood(survey_data$lower_PPI_Score, lower_lookup_table)
extreme_overall_poverty_likelihood <- compute_poverty_likelihood(survey_data$extreme_PPI_Score, extreme_lookup_table)

# Compute PPI score for males
upper_male_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(sex == "MALE") %>% pull(upper_PPI_Score),
  upper_lookup_table)
lower_male_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(sex == "MALE") %>% pull(lower_PPI_Score),
  lower_lookup_table)
extreme_male_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(sex == "MALE") %>% pull(extreme_PPI_Score),
  extreme_lookup_table)

# Compute PPI score for females
upper_female_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(sex == "FEMALE") %>% pull(upper_PPI_Score),
  upper_lookup_table)
lower_female_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(sex == "FEMALE") %>% pull(lower_PPI_Score),
  lower_lookup_table)
extreme_female_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(sex == "FEMALE") %>% pull(extreme_PPI_Score),
  extreme_lookup_table)

# Compute PPI score for youths (youth is defined as age < 35)
upper_youth_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(age < 35) %>% pull(upper_PPI_Score),
  upper_lookup_table)
lower_youth_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(age < 35) %>% pull(lower_PPI_Score),
  lower_lookup_table)
extreme_youth_poverty_likelihood <- compute_poverty_likelihood(
  survey_data %>% filter(age < 35) %>% pull(extreme_PPI_Score),
  extreme_lookup_table)

results_df <- data.frame(
  Category = c("Overall", "Male", "Female", "Youth"),
  Upper = c(upper_overall_poverty_likelihood, upper_male_poverty_likelihood, upper_female_poverty_likelihood, upper_youth_poverty_likelihood),
  Lower = c(lower_overall_poverty_likelihood, lower_male_poverty_likelihood, lower_female_poverty_likelihood, lower_youth_poverty_likelihood),
  Extreme = c(extreme_overall_poverty_likelihood, extreme_male_poverty_likelihood, extreme_female_poverty_likelihood, extreme_youth_poverty_likelihood))

results_df[ , c("Upper", "Lower", "Extreme")] <- round(results_df[ , c("Upper", "Lower", "Extreme")], 0)

# Rename columns
colnames(results_df) <- c("Category", "Upper National Poverty Line (%)", "Lower National Poverty Line (%)", "Extreme Poverty Line (%)")

add_lot_link(caption = 'Percentage (%) estimates of the Poverty Probability Index (PPI) for households')

# Use sea_table and flextable styling with updated column names and rounded values
results_df %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit() 
  

```

Village-specific percentage estimates of the PPI appear uniform across the survey area except for Ntanganyika, in which slightly fewer households appear to live below the upper, lower, and extreme poverty lines (Figure 3).

```{r,  fig.cap='Village-specific percentage estimates of the Poverty Probability Index (PPI) for households', fig.align='center', out.width = '90%'}

survey_data <- survey_data %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"))

# Compute poverty likelihood by village for upper, lower, and extreme levels
village_poverty_likelihood <- survey_data %>%
  group_by(village, cluster) %>%
  summarise(
    upper_poverty = compute_poverty_likelihood(upper_PPI_Score, upper_lookup_table),
    lower_poverty = compute_poverty_likelihood(lower_PPI_Score, lower_lookup_table),
    extreme_poverty = compute_poverty_likelihood(extreme_PPI_Score, extreme_lookup_table))

# Reshape the data for easier plotting
village_poverty_likelihood_long <- village_poverty_likelihood %>%
  pivot_longer(
    cols = c(upper_poverty, lower_poverty, extreme_poverty),
    names_to = "poverty_level",
    values_to = "poverty_likelihood")

village_poverty_likelihood_long <- village_poverty_likelihood_long %>%
  mutate(poverty_level = fct_relevel(poverty_level, "upper_poverty", "lower_poverty", "extreme_poverty"))

# Calculate overall means for Cluster 2
overall_poverty_likelihood <- village_poverty_likelihood_long %>%
  filter(cluster == "Cluster 2") %>%
  group_by(poverty_level, cluster) %>%
  summarise(poverty_likelihood = mean(poverty_likelihood, na.rm = TRUE), .groups = "drop") %>%
  mutate(village = "Overall")  # Add "Overall" as the village

# Append the overall data to the original dataframe
village_poverty_likelihood_long <- bind_rows(village_poverty_likelihood_long, overall_poverty_likelihood)

# Reorder x-axis to place "Overall" at the end of Cluster 2
village_poverty_likelihood_long <- village_poverty_likelihood_long %>%
  mutate(village = fct_reorder(village, as.numeric(factor(cluster)) + as.numeric(village == "Overall")))

# Plot with updated data
ggplot(village_poverty_likelihood_long, aes(x = village, y = poverty_likelihood, 
                                            group = poverty_level, fill = poverty_level)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_text(aes(label = paste0(round(poverty_likelihood, 0))), 
            position = position_dodge(width = 0.95), 
            vjust = -0.5, size = 3) +  # Add percentage labels above bars
  guides(fill = guide_legend(title = NULL)) +
  labs(x = "Village", y = "Percentage of Poverty Likelihood") +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = c(
    "extreme_poverty" = "Extreme Poverty Line (%)", 
    "lower_poverty" = "Lower National Poverty Line (%)", 
    "upper_poverty" = "Upper National Poverty Line (%)")) +
  labs(x = "", y = "") +  # Remove y-axis title
  sea::theme_sea() + 
  theme(
    legend.position = "bottom", 
    legend.direction = "horizontal", 
    legend.justification = "center", 
    axis.text.x = element_text(size = 7), axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.title.y = element_blank(), strip.text = element_blank(), panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), legend.box = "horizontal") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +  # Add space for labels above bars
  facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  theme(axis.text.x = element_text(size = 7))

```

<!-- inverse gunmetal page -->

<article class="section-gunmetal-inverse">

# Quantitative Analysis

</div>

<!-- gunmetal page -->
<div class="section-gunmetal">

## Livelihoods

### Household welfare self-assessment



```{r,  fig.cap='Self-assessment of the ability to meet daily needs at village level', fig.align='center', out.width = '90%'}

village_data <- tanganyika_survey %>%
  group_by(village, household_ability) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
    total = survey_total(vartype = "ci", na.rm = TRUE), 
    n = unweighted(n())) %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2"))

overall_north_data <- tanganyika_survey %>%
  filter(village %in% cluster_1_villages) %>%
  group_by(household_ability) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE),
            total = survey_total(vartype = "ci", na.rm = TRUE),
            n = unweighted(n())) %>%
  mutate(village = "Overall North", cluster = "Cluster 1")

overall_south_data <- tanganyika_survey %>%
  filter(village %in% cluster_2_villages) %>%
  group_by(household_ability) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE),
            total = survey_total(vartype = "ci", na.rm = TRUE),
            n = unweighted(n())) %>%
  mutate(village = "Overall South", cluster = "Cluster 2")

# Combine the original village_data, total_data, and new overall categories
village_data <- bind_rows(village_data, overall_north_data, overall_south_data)

# Reorder the village factor explicitly to place "Overall North" last
village_data <- village_data %>%
  mutate(village = factor(village, levels = c(
    setdiff(unique(village_data$village), "Overall North"),  # All villages except Overall North
    "Overall North")))

# Reorder  based on average proportion for each method
village_data$household_ability <- factor(
  village_data$household_ability,
  levels = village_data %>%
    group_by(household_ability) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(household_ability))

village_data <- village_data %>%
  mutate(household_ability = factor(
    household_ability, 
    levels = c(
      "WE CAN JUST MEET OUR DAILY NEEDS AND HAVE NO EXTRA THINGS", 
      "WE HAVE DIFFICULTY IN MEETING OUR DAILY NEEDS", 
      "WE HAVE ENOUGH TO MEET OUR DAILY NEEDS AND HAVE SOME EXTRA THINGS",
      "WE CAN MEET OUR DAILY NEEDS AND SAVE MONEY AFTERWARDS TOO")))

ggplot(village_data, aes(x = village, y = proportion * 100, group = household_ability, fill = household_ability)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  # geom_text(
  #   aes(label = paste0(round(proportion * 100, 0)), 
  #       y = pmin(proportion_upp, 1) * 100 + 2),  # Position just above the error bar
  #   position = position_dodge(width = 0.95), 
  #   vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 1)) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = c(
      "WE CAN JUST MEET OUR DAILY NEEDS AND HAVE NO EXTRA THINGS" = "Just sufficient", 
      "WE HAVE DIFFICULTY IN MEETING OUR DAILY NEEDS" = "With difficulty", 
      "WE HAVE ENOUGH TO MEET OUR DAILY NEEDS AND HAVE SOME EXTRA THINGS" = "Can meet needs",
      "WE CAN MEET OUR DAILY NEEDS AND SAVE MONEY AFTERWARDS TOO" = "Have extra")) +
  labs(x = "", y = "") +  # Remove axis titles
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
    # axis.text.y = element_blank(),  # Remove y-axis labels
    # axis.ticks.y = element_blank(),  # Remove y-axis ticks
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    strip.text = element_blank(), 
    legend.box = "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = label_percent(scale = 1)) 

```

83% of households indicated that they either have just enough or have difficulty meeting their daily needs (Figure 4). Approximately 5% of households were able to save extra. Even though there are some differences, this general picture roughly applies to all villages.

</div>

## Living Conditions, Housing, and Energy Use

### Water Use

Access to safe drinking water may depend on several variables including the source of the water and the ability to purify it. In this survey, responses were split between dry and rainy seasons, as water sources can change depending on the season.

Water sources were categorized as improved or unimproved sources following WHO and UNICEF standards (NBS & ICF Macro, 2011). Improved sources include public taps, protected private or public wells, and rainwater. Unimproved sources include open wells and surface water.

In the dry season, 62% percent of the households use an unimproved source, mainly surface water (i.e. rivers, streams, ponds, lakes), while in the wet season the use of rainwater reduces this to 25%. 

Use of the lake water is more common in the dry season when there are fewer alternatives. The most common improved source is a protected public tap followed by protected public wells.


```{r,  fig.cap='Main source of water', fig.align='center', out.width = '90%'}
# Combine data for wet and dry seasons
village_data_dry <- tanganyika_survey %>%
  group_by(drinking_water_dry) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    proportion_low = survey_mean(vartype = "ci", na.rm = TRUE)[2],
    proportion_upp = survey_mean(vartype = "ci", na.rm = TRUE)[3],
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(Season = "Dry", WaterSource = drinking_water_dry)

village_data_wet <- tanganyika_survey %>%
  group_by(drinking_water_wet) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    proportion_low = survey_mean(vartype = "ci", na.rm = TRUE)[2],
    proportion_upp = survey_mean(vartype = "ci", na.rm = TRUE)[3],
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(Season = "Wet", WaterSource = drinking_water_wet)

# Combine dataframes
village_data_combined <- bind_rows(village_data_dry, village_data_wet)

# Create grouped bar chart
ggplot(village_data_combined, aes(x = reorder(WaterSource, -proportion), y = proportion * 100, fill = Season)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
                position = position_dodge(width = 0.8), width = 0.2) +
  geom_text(aes(
    label = ifelse(proportion * 100 < 1, 
                   paste0(round(proportion * 100, 1), "%"), 
                   paste0(round(proportion * 100), "%")),
    y = pmin(proportion_upp * 100, 100) + 1.5),  # Position label above the error bar
    position = position_dodge(width = 0.8), vjust = 0, size = 2) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  labs(x = "", y = "", fill = "") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "bottom", 
        legend.title = element_blank()) +
  scale_x_discrete(labels = c("Rainwater", "River or Stream", "Public Tap", "Pond or Lake", "Open Public Well",
                              "Protected Public Well", "Spring", "Piped into Dwelling", "Water Vendor",
                              "Neighbour's Open Well", "Neighbour's Borehole", "Protected Well in Plot",
                              "Open Well in Plot", "Piped into Plot", "Neighbour's Tap", "Other"))

```

```{r}
improved_sources <- c("PUBLIC TAP", "PROTECTED PUBLIC WELL", "PROTECTED WELL IN PLOT", "RAINWATER")
unimproved_sources <- c("OPEN PUBLIC WELL", "OPEN WELL IN PLOT", "RIVER OR STREAM", "POND OR LAKE")

village_data_combined <- village_data_combined %>%
  mutate(SourceType = case_when(
    WaterSource %in% improved_sources ~ "Improved",
    WaterSource %in% unimproved_sources ~ "Unimproved",
    TRUE ~ "Other"
  ))

# Calculate proportions for wet and dry seasons
relative_proportions <- village_data_combined %>%
  group_by(Season, SourceType) %>%  # Include Season in grouping
  summarise(
    total_proportion = sum(proportion, na.rm = TRUE),
    total_n = sum(n, na.rm = TRUE)
  ) %>%
  mutate(percentage = total_proportion * 100) %>%
  arrange(factor(SourceType, levels = c("Improved", "Unimproved", "Other")))  # Ensure "Other" is at the bottom

village_data_combined <- village_data_combined %>%
  mutate(SourceType = case_when(
    WaterSource %in% improved_sources ~ "Improved",
    WaterSource %in% unimproved_sources | SourceType == "Other" ~ "Unimproved",
    TRUE ~ "Unimproved"  # Default to Unimproved if not classified
  ))

# Calculate proportions for wet and dry seasons in a wide format
season_proportions <- village_data_combined %>%
  group_by(Season, SourceType) %>%
  summarise(total_proportion = sum(proportion, na.rm = TRUE)) %>%
  mutate(percentage = round(total_proportion * 100)) %>%  # Round to nearest whole number
  select(Season, SourceType, percentage) %>%
  pivot_wider(names_from = SourceType, values_from = percentage, values_fill = 0)  # Ensure all columns exist even if proportions are zero

season_proportions <- season_proportions %>%
  rename(
    `Improved Season (%)` = "Improved",
    `Unimproved Season (%)` = "Unimproved")

# Display the flextable with Seasons as rows and source types as columns
season_proportions %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()

```

In the dry season, the majority of households use an appropriate water treatment method by boiling water prior to use (55%). A further 12% add bleach or chlorine. Ineffective methods include straining water through a cloth prior to drinking, which is practiced by 32% of households. In wet season, the proportion of households boiling water or adding bleach or chlorine prior to use drops to 43% and 8% respectively. This may likely be attributed to rainwater being the predominant water source during the wet season. Overall, very few households use a water filter.

A large amount of variation exists between the villages, ranging from fewer than a quarter to more than 80% of respondents using appropriate treatment methods. The addition of bleach or chlorine to water prior to use was highest in Isasa.


```{r,  fig.cap='Main type of water treatment in the dry season', fig.align='center', out.width = '90%'}

treatment_dry_expanded <- tanganyika_clean %>% select(hh_code, village, treatment_method_dry, stype, fpc) %>%
  separate_rows(treatment_method_dry, sep = "\\|") %>%
  mutate(treatment_method_dry = trimws(treatment_method_dry)) %>% drop_na()  

treatment_dry_expanded <- treatment_dry_expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

treatment_dry_design <- treatment_dry_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

treatment_data <- treatment_dry_design %>%
  group_by(village, cluster, treatment_method_dry) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- treatment_dry_design %>%
  filter(treatment_method_dry != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, treatment_method_dry) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
treatment_data <- bind_rows(treatment_data, overall_cluster_data)

treatment_data <- treatment_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(treatment_data$village[treatment_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(treatment_data$village[treatment_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
treatment_data$treatment_method_dry <- factor(
  treatment_data$treatment_method_dry,
  levels = treatment_data %>%
    group_by(treatment_method_dry) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(treatment_method_dry))

ggplot(treatment_data, aes(x = village, y = proportion * 100, group = treatment_method_dry, fill = treatment_method_dry)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
    position = position_dodge(width = 0.8), width = 0.25) +
  # geom_text(aes(
  #     label = paste0(round(proportion * 100, 0)),
  #     y = pmin(proportion_upp * 100, 100) + 2),
  #     position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 1, reverse = FALSE)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = c(
      "ADD BLEACH/CHLORINE" = "Add bleach or chlorine", 
      "BOIL" = "Boil",
      "LET IT STAND AND SETTLE" = "Let it stand and settle",
      "STRAIN THROUGH A CLOTH" = "Strain through a cloth",
      "USE WATER FILTER (CERAMIC/SAND/COMPOSITE/ETC.)" = "Use water filter")) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
    # axis.text.y = element_blank(),  # Remove y-axis labels
    # axis.ticks.y = element_blank(),  # Remove y-axis ticks
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    strip.text = element_blank(), 
    legend.box = "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = label_percent(scale = 1))

```


```{r,  fig.cap='Main type of water treatment in the wet season', fig.align='center', out.width = '90%'}

treatment_wet_expanded <- tanganyika_clean %>% select(hh_code, village, treatment_method_wet, stype, fpc) %>%
  separate_rows(treatment_method_wet, sep = "\\|") %>%
  mutate(treatment_method_wet = trimws(treatment_method_wet)) %>% drop_na()  

treatment_wet_expanded <- treatment_wet_expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

treatment_wet_design <- treatment_wet_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

treatment_data <- treatment_wet_design %>%
  group_by(village, cluster, treatment_method_wet) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- treatment_wet_design %>%
  filter(treatment_method_wet != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, treatment_method_wet) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
treatment_data <- bind_rows(treatment_data, overall_cluster_data)

treatment_data <- treatment_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(treatment_data$village[treatment_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(treatment_data$village[treatment_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
treatment_data$treatment_method_wet <- factor(
  treatment_data$treatment_method_wet,
  levels = treatment_data %>%
    group_by(treatment_method_wet) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(treatment_method_wet))

ggplot(treatment_data, aes(x = village, y = proportion * 100, group = treatment_method_wet, fill = treatment_method_wet)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
    position = position_dodge(width = 0.8), width = 0.25) +
  # geom_text(aes(
  #     label = paste0(round(proportion * 100, 0)),
  #     y = pmin(proportion_upp * 100, 100) + 2), 
  #     position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 1, reverse = FALSE)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = c(
      "ADD BLEACH/CHLORINE" = "Add bleach or chlorine", 
      "BOIL" = "Boil",
      "STRAIN THROUGH A CLOTH" = "Strain through a cloth",
      "USE WATER FILTER (CERAMIC/SAND/COMPOSITE/ETC.)" = "Use water filter")) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
    # axis.text.y = element_blank(),  # Remove y-axis labels
    # axis.ticks.y = element_blank(),  # Remove y-axis ticks
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    strip.text = element_blank(), legend.box = 
        "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = label_percent(scale = 1))

```

</div>
\newpage

### Sanitation

A household’s toilet facility and whether it must be shared with other households is an important welfare and health indicator. Across the study area, 22% of respondents indicated that they share their toilet facility with other households (Table 6). More than half of all households use an open pit latrine without a slab (57%). Pit latrines with a slab were used by 13%, whereas a further 17% of household indicated that they pour or flush into a pit latrine. 

```{r}
# Summarize the data by village shared_facilities
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(shared_facilities) & shared_facilities != "I DO NOT WANT TO ANSWER" & shared_facilities != "I DON'T KNOW") %>% 
  group_by(village, shared_facilities) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
share_facility_table <- summary_by_village %>%
  select(village, shared_facilities, proportion) %>%
  pivot_wider(names_from = shared_facilities, values_from = proportion)

# Rename columns for clarity
colnames(share_facility_table) <- c("village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
share_facility_table <- share_facility_table %>%
  mutate(across(c("Yes", "No"), ~ paste0(round(. * 100, 0))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(toilet_facilities) & toilet_facilities != "I DON'T KNOW" & toilet_facilities != "OTHER") %>% 
  group_by(village, toilet_facilities) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

toilet_table <- summary_by_village %>%
  select(village, toilet_facilities, proportion) %>%
  pivot_wider(names_from = toilet_facilities, values_from = proportion   )

# Rename columns for clarity
colnames(toilet_table) <- c("Village", "Flush to Elsewhere", "Flush to Pit Latrine", "No Facility", "Pit Latrine with Slab", "Pit Latrine without Slab", "Composting Toilet", "Ventilated Improved Pit (VIP) Latrine")

# Format the proportion table values as percentages with one decimal point and add % sign, leave NA as blank
toilet_table <- toilet_table %>%
  mutate(across(c("Flush to Elsewhere", "Flush to Pit Latrine", "No Facility", "Pit Latrine with Slab", "Pit Latrine without Slab", "Composting Toilet", "Ventilated Improved Pit (VIP) Latrine"),
                ~ ifelse(is.na(.), "", paste0(round(. * 100, 0)))))

# Combine the 'Yes' column from share_facility_table with toilet_table
combined_table <- toilet_table %>%
  left_join(
    share_facility_table %>% select(village, `Shared Sanitation Facility` = Yes),
    by = c("Village" = "village"))

# Calculate the overall average for all villages combined
total_row <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Shared Sanitation Facility` = survey_mean(shared_facilities == "YES", na.rm = TRUE) * 100,
    `Flush to Elsewhere` = survey_mean(toilet_facilities == "FLUSH/ POUR FLUSH TO ELSEWHERE", na.rm = TRUE) * 100,
    `Flush to Pit Latrine` = survey_mean(toilet_facilities == "FLUSH/ POUR FLUSH TO PIT LATRINE", na.rm = TRUE) * 100,
    `No Facility` = survey_mean(toilet_facilities == "NO FACILITY/BUSH/FIELD", na.rm = TRUE) * 100,
    `Pit Latrine with Slab` = survey_mean(toilet_facilities == "PIT LATRINE WITH SLAB", na.rm = TRUE) * 100,
    `Pit Latrine without Slab` = survey_mean(toilet_facilities == "PIT LATRINE WITHOUT SLAB/OPEN PIT", na.rm = TRUE) * 100,
    `Composting Toilet` = survey_mean(toilet_facilities == "COMPOSTING TOILET/ECOSAN", na.rm = TRUE) * 100,
    `Ventilated Improved Pit (VIP) Latrine` = survey_mean(toilet_facilities == "VENTILATED IMPROVED PIT (VIP) LATRINE", na.rm = TRUE) * 100) %>%
  mutate(
    `Shared Sanitation Facility` = paste0(round(`Shared Sanitation Facility`, 0)),
    `Flush to Elsewhere` = paste0(round(`Flush to Elsewhere`, 0)),
    `Flush to Pit Latrine` = paste0(round(`Flush to Pit Latrine`, 0)),
    `No Facility` = paste0(round(`No Facility`, 0)),
    `Pit Latrine with Slab` = paste0(round(`Pit Latrine with Slab`, 0)),
    `Pit Latrine without Slab` = paste0(round(`Pit Latrine without Slab`, 0)),
    `Composting Toilet` = paste0(round(`Composting Toilet`, 0)),
    `Ventilated Improved Pit (VIP) Latrine` = paste0(round(`Ventilated Improved Pit (VIP) Latrine`, 0))) %>%
  # Remove columns with "_se" in their names
  select(-contains("_se"))

combined_table <- combined_table %>%
  mutate(across(everything(), as.character))

# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)

# Reorder columns to place 'Shared Sanitation Facility' on the left
combined_table <- combined_table %>%
  select(`Village`, `Shared Sanitation Facility`, everything())

# Ensure NA values are replaced with blanks
combined_table <- combined_table %>%
  mutate(across(everything(), ~ ifelse(is.na(.), "", .)))

# Display the flextable with a caption
add_lot_link(caption = 'Sanitation facilities at village level (%)')

combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit() %>%
  flextable::fontsize(size = 10, part = "header")

```

Overall, only 25% of households had handwashing facilities available. Households in Kalungu, Mtakuja, and Isasa contained the highest proportion of handwashing facilities. Where handwashing facilities were available, 53% of households indicated there was water and 39% had soap available. Tippy taps were encountered across 8% of all households.

```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(handwashing_place) & handwashing_place != "I DO NOT WANT TO ANSWER" & handwashing_place != "I DON'T KNOW") %>% 
  group_by(village, handwashing_place) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
handwashing_place_table <- summary_by_village %>%
  select(village, handwashing_place, proportion) %>%
  pivot_wider(names_from = handwashing_place, values_from = proportion)

# Rename columns for clarity
colnames(handwashing_place_table) <- c("village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
handwashing_place_table <- handwashing_place_table %>%
  mutate(across(c("Yes", "No"), ~ paste0(round(. * 100, 0))))

handwashing_show_expanded <- tanganyika_clean %>% select(hh_code, village, handwashing_show, stype, fpc) %>%
  separate_rows(handwashing_show, sep = "\\|") %>%
  mutate(handwashing_show = trimws(handwashing_show)) %>% drop_na()  

handwashing_show_design <- handwashing_show_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

summary_by_village <- handwashing_show_design %>%
  group_by(village, handwashing_show) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

handwashing_table <- summary_by_village %>%
  select(village, handwashing_show, proportion) %>%
  pivot_wider(names_from = handwashing_show, values_from = proportion)

# Rename columns for clarity
colnames(handwashing_table) <- c("Village", "Soap", "Tippy Tap", "Water")

# Format the proportion table values as percentages with one decimal point and add % sign, leave NA as blank
handwashing_table <- handwashing_table %>%
  mutate(across(c("Soap", "Tippy Tap", "Water"),
                ~ ifelse(is.na(.), "", paste0(round(. * 100, 0)))))

# Combine the 'Yes' column from share_facility_table with toilet_table
combined_table <- handwashing_table %>%
  left_join(
    handwashing_place_table %>% select(village, `Handwashing Place Available` = Yes),
    by = c("Village" = "village"))

# Reorder columns to place 'Shared Facility - Yes' on the left
combined_table <- combined_table %>%
  select(`Village`, `Handwashing Place Available`, everything())

# Calculate the overall average for all villages combined
total_row_place <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Handwashing Place Available` = survey_mean(handwashing_place == "YES", na.rm = TRUE) * 100) %>%
  mutate(
    `Handwashing Place Available` = paste0(round(`Handwashing Place Available`, 0))) %>% select(-contains("_se"))

# Calculate the overall average for all villages combined
total_row_show <- handwashing_show_design %>%
  summarise(
    Village = "Overall",
    `Soap` = survey_mean(handwashing_show == "HAS SOAP", na.rm = TRUE) * 100,
    `Tippy Tap` = survey_mean(handwashing_show == "HAS TIPPY TAP", na.rm = TRUE) * 100,
    `Water` = survey_mean(handwashing_show == "HAS WATER", na.rm = TRUE) * 100) %>%
  mutate(
    `Soap` = paste0(round(`Soap`, 0)),
    `Tippy Tap` = paste0(round(`Tippy Tap`, 0)),
    `Water` = paste0(round(`Water`, 0))) %>%
  # Remove columns with "_se" in their names
  select(-contains("_se"))

total_row <- left_join(total_row_place, total_row_show, by = "Village") %>%
  select(Village, `Handwashing Place Available`, Soap, `Tippy Tap`, Water)

combined_table <- combined_table %>%
  mutate(across(everything(), as.character))

# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)

# Reorder columns to place 'Handwashing Place Available' on the left
combined_table <- combined_table %>%
  select(`Village`, `Handwashing Place Available`, everything())

# Ensure NA values are replaced with blanks
combined_table <- combined_table %>%
  mutate(across(everything(), ~ ifelse(is.na(.), "", .)))

# Display the flextable with a caption
add_lot_link(caption = 'Handwashing at village level (%)')

combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>% flextable::autofit()


```



</div>
\newpage

### Household Amenities

Beds and mattresses are most commonly owned of the listed household goods (21%; Figure 8). Thereafter, mobile phones are owned by 17.8% of households, a further 4.2% of respondents indicated owning a smartphone. This is significantly lower than the national average of 83% of households that own a mobile phone (2022 TDHSMIS). Radio ownership across the survey population (11%) was also significantly lower than both the 2011 Tuungane survey (75%) and the 2022 national average (44%; 2022 TDHSMIS). 

```{r,  fig.cap='Household item ownership', fig.align='center', out.width = '90%'}
household_item_expanded <- tanganyika_clean %>% select(hh_code, village, household_item, stype, fpc) %>%
  separate_rows(household_item, sep = "\\|") %>%
  mutate(household_item = trimws(household_item)) %>% 
  filter(!is.na(household_item) & household_item != "") %>% drop_na()  

# Split data based on clusters
household_item_expanded_cluster_1 <- household_item_expanded %>%
  filter(village %in% cluster_1_villages)

household_item_expanded_cluster_2 <- household_item_expanded %>%
  filter(village %in% cluster_2_villages)

# Create survey designs for each cluster
household_item_design_cluster_1 <- household_item_expanded_cluster_1 %>%
  as_survey_design(ids = hh_code, strata = stype, fpc = fpc, nest = TRUE)

household_item_design_cluster_2 <- household_item_expanded_cluster_2 %>%
  as_survey_design(ids = hh_code, strata = stype, fpc = fpc, nest = TRUE)

# Summarise for cluster 1
household_item_data_cluster_1 <- household_item_design_cluster_1 %>%
  group_by(household_item) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>% ungroup()

# Summarise for cluster 2
household_item_data_cluster_2 <- household_item_design_cluster_2 %>%
  group_by(household_item) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>% ungroup()

# Combine the two clusters' data
household_item_data_combined <- bind_rows(
  household_item_data_cluster_1 %>% mutate(cluster = "Overall North"),
  household_item_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows
ggplot(household_item_data_combined, aes(x = reorder(household_item, -proportion), y = proportion * 100, fill = reorder(household_item, -proportion))) + 
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1)*100, ymin = pmax(proportion_low, 0)*100),
                width = 0.2) +
  geom_text(aes(
    label = paste0(round(proportion * 100, 1), "%"),
    y = pmin(proportion_upp * 100, 100) + 2), 
    position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 3)) +
  labs(x = "", y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none",  # Remove the legend
        axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +  # Rotate x-axis labels
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Bed or Mattress", "Mobile Phone", "Solar Panel", "Table", "Radio", "TV", "Smartphone", "TANESCO Power", "Iron", "Sofa", "Refrigerator", "Clock", "Generator")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster



```

Only 1% of households indicated having access to clean cooking fuel, namely gas. The vast majority of the survey population use solid fuels such as charcoal (53%) and firewood (46%) (Figure 9). This is comparable to the national average, in which 93% of Tanzanian households make use of solid fuels including charcoal and firewood (2022 TDHSMIS). Interestingly, among the northern cluster of villages, with the exception of Wampembe, households appear to use firewood as the primary cooking fuel. In contrast, the majority of villages in the southern cluster make use of charcoal. Gas was only used as a cooking fuel amongst eight villages, of which Kipili indicated the highest use (9%). 

```{r, fig.cap='Types of cooking fuels used at village level (%)', fig.align='center', out.width = '90%'}
fuel_expanded <- tanganyika_clean %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

fuel_design <- fuel_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

fuel_data <- fuel_design %>%
  group_by(village, cluster, cooking_fuel) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- fuel_design %>%
  filter(cooking_fuel != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, cooking_fuel) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
fuel_data <- bind_rows(fuel_data, overall_cluster_data)

fuel_data <- fuel_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(fuel_data$village[fuel_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(fuel_data$village[fuel_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
fuel_data$cooking_fuel <- factor(
  fuel_data$cooking_fuel,
  levels = fuel_data %>%
    group_by(cooking_fuel) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(cooking_fuel))

ggplot(fuel_data, aes(x = village, y = proportion * 100, group = cooking_fuel, fill = cooking_fuel)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = NULL, y = NULL) +
 scale_fill_viridis(discrete = TRUE, option = "D", labels = c(
      "CHARCOAL" = "Charcoal", 
      "CROP RESIDUALS" = "Crop Residuals",
      "FIREWOOD" = "Firewood",
      "GAS" = "Gas",
      "OTHER" = "Other")) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
        axis.text.x = element_text(size = 7), panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), strip.text = element_blank(), legend.box = 
        "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_y_continuous(labels = label_percent(scale = 1))+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))

```


Half of the households surveyed owned a fuel-efficient stove (51%), which is higher than the 27% indicated by the 2011 Tuungane survey (Table 8). Of the households that owned a fuel-efficient stove, the majority of respondents use it every day for cooking (89%). Fuel-efficient stove ownership was highest in Mkinga (72%) and Mpasa (71%). Katenge had the lowest fuel-efficient stove ownership (13%), however among households that owned a fuel-efficient stove, daily use was ubiquitous (Table 8).


```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(efficient_stove) & efficient_stove != "I DON'T KNOW" & efficient_stove != "I DO NOT WANT TO ANSWER") %>% 
  group_by(village, efficient_stove) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
efficient_stove_table <- summary_by_village %>%
  select(village, efficient_stove, proportion) %>%
  pivot_wider(names_from = efficient_stove, values_from = proportion)

# Rename columns for clarity
colnames(efficient_stove_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
efficient_stove_table <- efficient_stove_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

expanded <- tanganyika_clean %>% select(hh_code, village, efficient_stove_use, stype, fpc) %>%
  separate_rows(efficient_stove_use, sep = "\\|") %>%
  mutate(efficient_stove_use = trimws(efficient_stove_use)) %>% drop_na()  

expanded <- expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

design <- expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

efficient_stove_use_data <- design %>%
  group_by(village, cluster, efficient_stove_use) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
proportion_table <- efficient_stove_use_data %>%
  select(village, efficient_stove_use, proportion) %>%
  pivot_wider(
    names_from = efficient_stove_use,    
    values_from = proportion)

# Rename columns for clarity
colnames(proportion_table) <- c("Village", "Almost everyday", "At least once a week", "Less than once a week")

# Format the proportion table values as percentages with one decimal point and add % sign, leave NA as blank
proportion_table <- proportion_table %>%
  mutate(across(c("Almost everyday", "At least once a week", "Less than once a week"),
                ~ ifelse(is.na(.), "", paste0(round(. * 100, 0)))))

combined_table <- efficient_stove_table %>%
  select(Village, `Efficient Stove Ownership` = Yes) %>%
  left_join(proportion_table %>% select(Village, `Almost everyday`, `At least once a week`, `Less than once a week`), by = "Village") 

total_row_stove <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Efficient Stove Ownership` = survey_mean(efficient_stove == "YES", na.rm = TRUE) * 100) %>%
  mutate(
    `Efficient Stove Ownership` = paste0(round(`Efficient Stove Ownership`, 0))) %>% select(-contains("_se"))

# Calculate the overall average for all villages combined
total_row_use <- design %>%
  summarise(
    Village = "Overall",
    `Almost everyday` = survey_mean(efficient_stove_use == "ALMOST EVERY DAY", na.rm = TRUE) * 100,
    `At least once a week` = survey_mean(efficient_stove_use == "AT LEAST ONCE A WEEK", na.rm = TRUE) * 100,
    `Less than once a week` = survey_mean(efficient_stove_use == "LESS THAN ONCE A WEEK", na.rm = TRUE) * 100) %>%
  mutate(
    `Almost everyday` = paste0(round(`Almost everyday`, 0)),
    `At least once a week` = paste0(round(`At least once a week`, 0)),
    `Less than once a week` = paste0(round(`Less than once a week`, 0))) %>%
  # Remove columns with "_se" in their names
  select(-contains("_se"))

total_row <- left_join(total_row_stove, total_row_use, by = "Village") %>%
  select(Village, `Efficient Stove Ownership`, `Almost everyday`, `At least once a week`, `Less than once a week`)

# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)
colnames(combined_table) <- c("Village", "Efficient Stove Ownership (%)", "Almost everyday (%)", "At least once a week (%)", "Less than once a week (%)")

add_lot_link(caption = 'Efficient stove ownership and use at village level (%)')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white") %>%
  flextable::autofit()

```

</div>
\newpage

<!-- rust page -->
<div class ="section-rust">

### Livelihood Activities

45% of households are engaged in agriculture and/or livestock keeping (Figure 10), which is markedly less than the 97% indicated by the 2011 Tuungane survey. Agriculture was the main livelihood activity in all villages except for Manda Kerenge, in which fishing was the most frequent activity. Overall, 40% of households are engaged in fish-based livelihood activities, including fishing (27%), fish trading (8%), and fish processing (5%). A further 9% of household respondents were engaged in business activities. 

Respondents were also asked to rank livelihood activities based on their importance. Relatively, agriculture was listed as the most important livelihood activity (44%), followed by fishing (27%), and business activities (9%). 


```{r,  fig.cap='Livelihood activities across Lake Tanganyika. Note: the allocated proportions represent the relative frequency of all livelihood activities engaged in by household members', fig.align='center', out.width = '90%'}
livelihood_activities_expanded <- tanganyika_clean %>% select(hh_code, village, livelihood_activities, stype, fpc) %>%
  separate_rows(livelihood_activities, sep = "\\|") %>%
  mutate(livelihood_activities = trimws(livelihood_activities)) %>% drop_na()  

livelihood_activities_expanded <- livelihood_activities_expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

# Split data based on clusters
livelihood_activities_expanded_cluster_1 <- livelihood_activities_expanded %>%
  filter(village %in% cluster_1_villages)

livelihood_activities_expanded_cluster_2 <- livelihood_activities_expanded %>%
  filter(village %in% cluster_2_villages)

# Create survey designs for each cluster
livelihood_activities_design_cluster_1 <- livelihood_activities_expanded_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

livelihood_activities_design_cluster_2 <- livelihood_activities_expanded_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarise for cluster 1
livelihood_data_cluster_1 <- livelihood_activities_design_cluster_1 %>%
  group_by(livelihood_activities) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
    total = survey_total(vartype = "ci", na.rm = TRUE), 
    n = unweighted(n())) %>% ungroup()

# Summarise for cluster 2
livelihood_data_cluster_2 <- livelihood_activities_design_cluster_2 %>%
  group_by(livelihood_activities) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
    total = survey_total(vartype = "ci", na.rm = TRUE), 
    n = unweighted(n())) %>% ungroup()

# Combine the two clusters' data
livelihood_data_combined <- bind_rows(
  livelihood_data_cluster_1 %>% mutate(cluster = "Overall North"),
  livelihood_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(livelihood_data_combined, aes(x = reorder(livelihood_activities, -proportion), 
                                    y = proportion * 100, fill = reorder(livelihood_activities, -proportion))) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1)*100, ymin = pmax(proportion_low, 0)*100), width = 0.2) +
  geom_text(aes(
    label = paste0(round(proportion * 100, 1), "%"),
    y = pmin(proportion_upp * 100, 100) + 2), 
    position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 3)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none",  # Remove the legend
        axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Agriculture", "Fishing", "Business", "Fish Trading", "Fish Processing", "Other", 
                              "Livestock Keeping", "Day Labor", "Taylor", "Employee", "Boat Builder", "Remittances", "Pensions")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

\newpage

## Access to Credit

Overall, 18% of the households had borrowed money at least once in the previous year (Figure 11). The proportion of households that took out credit is highest in Kichangani and Wampembe and lowest in Ng’anga and Tundu.

```{r, fig.cap='Proportion of households that borrowed money in the last year at village level (%)', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
  group_by(village, borrow_status) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(borrow_status == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), borrow_status) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(borrow_status == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

cluster_1_order <- c(
  "Izinga", "Kala", "Katenge", "Kilambo cha Mkolechi", 
  "Kizumbi", "Lyapinda", "Mpasa", "Mwinza", "Ng'anga", 
  "Tundu", "Wampembe", "Overall North")

# Adjust factor levels for villages in Cluster 1 and Cluster 2
village_data_yes <- village_data_yes %>%
  mutate(
    village = factor(
      village,
      levels = c(
        cluster_1_order,  # Use the specified order for Cluster 1
        setdiff(unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]), "Overall South"),
        "Overall South")))

# Create the plot
ggplot(village_data_yes, aes(x = village, y = proportion * 100, group = borrow_status, fill = borrow_status)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(aes(
      label = paste0(round(proportion * 100, 0), "%"),
      y = pmin(proportion_upp * 100, 100) + 2), 
      position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size=8), 
    strip.text = element_blank(), 
    axis.title.x = element_blank(),
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = NULL) 
```

Business expenses (23%) and farming expenses (21%) were the most common reasons for taking out a loan (Figure 12). Other common reasons for taking out a loan included covering household expenses (17%), food (16%), and medical expenses (16%). 

```{r, fig.cap='Purpose of the loan', fig.align='center', out.width = '90%'}
loan_usage_expanded <- tanganyika_clean %>% select(hh_code, village, loan_usage, stype, fpc) %>%
  separate_rows(loan_usage, sep = "\\|") %>%
  mutate(loan_usage = trimws(loan_usage)) %>% 
  filter(!is.na(loan_usage) & loan_usage != "") %>% drop_na()  

# Split data based on clusters
loan_usage_expanded_cluster_1 <- loan_usage_expanded %>%
  filter(village %in% cluster_1_villages)

loan_usage_expanded_cluster_2 <- loan_usage_expanded %>%
  filter(village %in% cluster_2_villages)

# Create survey designs for each cluster
loan_usage_design_cluster_1 <- loan_usage_expanded_cluster_1 %>%
  as_survey_design(ids = hh_code, strata = stype, fpc = fpc, nest = TRUE)

loan_usage_design_cluster_2 <- loan_usage_expanded_cluster_2 %>%
  as_survey_design(ids = hh_code, strata = stype, fpc = fpc, nest = TRUE)

# Summarise for cluster 1
loan_usage_data_cluster_1 <- loan_usage_design_cluster_1 %>%
  filter(!(village == "Ng'anga")) %>%
  group_by(loan_usage) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>% ungroup()

# Summarise for cluster 2
loan_usage_data_cluster_2 <- loan_usage_design_cluster_2 %>%
  filter(!(village == "Ng'anga")) %>%
  group_by(loan_usage) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>% ungroup()

# Combine the two clusters' data
loan_usage_data_combined <- bind_rows(
  loan_usage_data_cluster_1 %>% mutate(cluster = "Overall North"),
  loan_usage_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(loan_usage_data_combined, aes(x = reorder(loan_usage, -proportion), 
                                    y = proportion * 100, fill = reorder(loan_usage, -proportion))) + 
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1)*100, ymin = pmax(proportion_low, 0)*100), width = 0.2) +
  geom_text(aes(
    label = paste0(round(proportion * 100, 1), "%"),
    y = pmin(proportion_upp * 100, 100) + 2), 
    position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 3)) +
  labs(x = "", y = "") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none",  # Remove the legend
        axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Business", "Farming", "Household Expenses", "Food", "Medical Expenses", "School Fees", "Other")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

 
```

Almost half the borrowing households receive their loans from friends or neighbours and roughly a quarter of loans were given by family (Figure 13). Community Conservation Banks (COCOBA), Savings and Credit Societies (SACCO), Fisher Committee (FICO), and Village Community Banks (VICOBA) accounted for 6% of loans given. COCOBA, SACCOS, and VICOBA all provide savings and loan schemes to groups of villagers.

```{r, fig.cap='Source of loans', fig.align='center', out.width = '90%'}
borrowing_source_expanded <- tanganyika_clean %>% select(hh_code, village, borrowing_source, stype, fpc) %>%
  separate_rows(borrowing_source, sep = "\\|") %>%
  mutate(borrowing_source = trimws(borrowing_source)) %>% 
  filter(!is.na(borrowing_source) & borrowing_source != "" & borrowing_source != "I DO NOT WANT TO ANSWER") %>% drop_na() 

# Split data based on clusters
borrowing_source_expanded_cluster_1 <- borrowing_source_expanded %>%
  filter(village %in% cluster_1_villages)

borrowing_source_expanded_cluster_2 <- borrowing_source_expanded %>%
  filter(village %in% cluster_2_villages)

# Create survey designs for each cluster
borrowing_source_design_cluster_1 <- borrowing_source_expanded_cluster_1 %>%
  as_survey_design(ids = hh_code, strata = stype, fpc = fpc, nest = TRUE)

borrowing_source_design_cluster_2 <- borrowing_source_expanded_cluster_2 %>%
  as_survey_design(ids = hh_code, strata = stype, fpc = fpc, nest = TRUE)

# Summarise for cluster 1
borrowing_source_data_cluster_1 <- borrowing_source_design_cluster_1 %>%
  filter(!(village == "Ng'anga")) %>%
  group_by(borrowing_source) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>% ungroup()

# Summarise for cluster 2
borrowing_source_data_cluster_2 <- borrowing_source_design_cluster_2 %>%
  filter(!(village == "Ng'anga")) %>%
  group_by(borrowing_source) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>% ungroup()

# Combine the two clusters' data
borrowing_source_data_combined <- bind_rows(
  borrowing_source_data_cluster_1 %>% mutate(cluster = "Overall North"),
  borrowing_source_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(borrowing_source_data_combined, aes(x = reorder(borrowing_source, -proportion), 
                                          y = proportion * 100, fill = reorder(borrowing_source, -proportion))) + 
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1)*100, ymin = pmax(proportion_low, 0)*100), width = 0.2) +
  geom_text(aes(
    label = paste0(round(proportion * 100, 0), "%"),
    y = pmin(proportion_upp * 100, 100) + 2), 
    position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 3)) +
  labs(x = "", y = "") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none",  # Remove the legend
        axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Friends or Neighbours", "Family", "Traders", "Bank", 
                              "COCOBA/SACCO/FICO/VIKOBA", "Microcredit Institution", "Mpesa")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

The most common reason for not taking out a loan was the fear of being in debt, which was listed by 37% of respondents that didn’t borrow money in the past year (Figure 14). A further 18% of respondents stated that they found the process of taking out a loan too difficult or had no need for doing so (16%). 

```{r,  fig.cap='Reason for not having borrowed any money in the previous year', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
    group_by(not_borrowed) %>%
    summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% drop_na()

# Split data based on clusters
village_data_cluster_1 <- tanganyika_survey %>%
  filter(village %in% cluster_1_villages) %>%
  group_by(not_borrowed) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE),
            total = survey_total(vartype = "ci", na.rm = TRUE),
            n = unweighted(n())) %>%
  drop_na()

village_data_cluster_2 <- tanganyika_survey %>%
  filter(village %in% cluster_2_villages) %>%
  group_by(not_borrowed) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE),
            total = survey_total(vartype = "ci", na.rm = TRUE),
            n = unweighted(n())) %>%
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(village_data_combined, aes(x = reorder(not_borrowed, -proportion), 
                                  y = proportion * 100, fill = reorder(not_borrowed, -proportion))) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(aes(
      label = paste0(round(proportion * 100, 0), "%"),
      y = pmin(proportion_upp * 100, 100) + 2), 
      position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 3)) +
  labs(x = "", y = "") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none",  # Remove the legend
        axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Afraid to be in debt", "Process too\ndifficult", "No need", 
                              "Lack of sufficient\neducation on loans", "Repayment time\ntoo short", 
                              "Other", "No collateral\nfor loan")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster


```

Overall, 6% of household respondents across all villages stated that they were a member of a COCOBA, SACCO, or FICO (Figure 15). Membership was highest in Manda Uhuru (30%). Only two villages of the northern cluster contained households with COCOBA/SACCO/FICO members, namely Katenge and Wampembe. 

```{r, fig.cap='Household membership of a COCOBA, SACCO, or FICO at village level (%)', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
  group_by(village, cocoba_saccos) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  # Create a full dataset to keep village names, with NA for missing "YES" entries
  complete(tanganyika_survey$village, fill = list(proportion = NA, cocoba_saccos = "NO"))

village_data <- village_data %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1", 
    village %in% cluster_2_villages ~ "Cluster 2", 
    TRUE ~ "Other"
  ))

# Filter for "YES" entries in bmu_bylaws for plotting
village_data_yes <- village_data %>%
  filter(cocoba_saccos == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), cocoba_saccos) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(cocoba_saccos == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

cluster_1_order <- c(
  "Izinga", "Kala", "Katenge", "Kilambo cha Mkolechi", 
  "Kizumbi", "Lyapinda", "Mpasa", "Mwinza", "Ng'anga", 
  "Tundu", "Wampembe", "Overall North")

# Adjust factor levels for villages in Cluster 1 and Cluster 2
village_data <- village_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        cluster_1_order,  # Use the specified order for Cluster 1
        setdiff(unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]), "Overall South"),
        "Overall South")))

# Create the plot
ggplot(village_data, aes(x = village, y = proportion * 100, group = cocoba_saccos, fill = cocoba_saccos)) +
  geom_bar(data = village_data_yes, stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    data = village_data_yes,
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    data = village_data_yes,
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")),
    position = position_dodge(width = 0.95), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size = 8), 
    strip.text = element_blank(), 
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),  
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()) + 
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = label_percent(scale = 1), limits = c(0, 50)) +
  geom_bar(data = filter(village_data, cocoba_saccos == "NO"), 
           stat = "identity", 
           position = position_dodge(preserve = "single"), 
           width = 0.95, 
           fill = "white", 
           alpha = 0) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x")
```

A majority of households use mobile phones to make financial transactions (65%; Figure 16). The frequency of mobile transactions is relatively high, notably so in Isasa (90%) and Mtakjua (82%), only in Ng’anga did less than half of the household make use a mobile phone to make transactions. 

```{r, fig.cap='Mobile phone usage for financial transactions at village level (%)', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
  group_by(village, mobile_money) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(mobile_money == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), mobile_money) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(mobile_money == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

village_data_yes <- village_data_yes %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(village_data_yes$village[village_data_yes$cluster == "Cluster 1"]),
        unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]))))


# Create the plot
ggplot(village_data_yes, aes(x = village, y = proportion * 100, group = mobile_money, fill = mobile_money)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    data = village_data_yes,
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")),
    position = position_dodge(width = 0.95), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    strip.text = element_blank(), 
    axis.title.x = element_blank(),  
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))
```


</div>

## Food Security and Consumption

All households (not just fishers) were asked how often they eat fish (Figure 17). Migebuka is consumed most frequently on a daily basis, this differs from the 2011 Tuungane survey findings, in which dagaa was consumed most frequently and most often. Consumption of dagaa is most common on a weekly basis.  Other fish are consumed frequently less than once a week. Almost two thirds of the fish eaten in the past week stemmed from purchases (62%), whereas approximately a third was eaten from own catch (31%; Figure 18). 

```{r, fig.cap='Frequency of eating different fish species ', fig.align='center', out.width = '90%'}

# Filter out "NEVER" and "I DON'T KNOW"
filtered_data <- tanganyika_clean %>%
  filter(
    !dagaa %in% c("NEVER", "I DON'T KNOW"),
    !migebuka %in% c("NEVER", "I DON'T KNOW"),
    !other_fish %in% c("NEVER", "I DON'T KNOW"))

# Split data by clusters
fish_data_cluster_1 <- filtered_data %>%
  filter(village %in% cluster_1_villages) %>%
  pivot_longer(
    cols = c(dagaa, migebuka, other_fish),
    names_to = "fish_type",
    values_to = "frequency")

fish_data_cluster_2 <- filtered_data %>%
  filter(village %in% cluster_2_villages) %>%
  pivot_longer(
    cols = c(dagaa, migebuka, other_fish),
    names_to = "fish_type",
    values_to = "frequency")

# Create survey design objects
fish_design_cluster_1 <- fish_data_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

fish_design_cluster_2 <- fish_data_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Calculate fish proportions for each cluster
fish_proportions_cluster_1 <- fish_design_cluster_1 %>%
  group_by(fish_type, frequency) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>%
  ungroup()

fish_proportions_cluster_2 <- fish_design_cluster_2 %>%
  group_by(fish_type, frequency) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>%
  ungroup()

# Combine the two clusters' data
fish_proportions_combined <- bind_rows(
  fish_proportions_cluster_1 %>% mutate(cluster = "Overall North"),
  fish_proportions_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the grouped bar chart with clusters
ggplot(fish_proportions_combined, aes(x = fish_type, y = proportion, fill = frequency)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 100), ymin = pmax(proportion_low, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  geom_text(aes(y = pmin(proportion_upp, 100) + 0.04, 
                label = scales::percent(proportion, accuracy = 1)),
            position = position_dodge(width = 0.95), size = 3) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = NULL, y = NULL, fill = "Frequency of Consumption") +
  scale_fill_viridis(discrete = TRUE, option = "D",labels = c("LESS THAN ONCE A WEEK" = "Less than Weekly",
                                          "AT LEAST ONCE A WEEK" = "Weekly",
                                          "ALMOST EVERY DAY" = "Daily")) +
  sea::theme_sea() +
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
        axis.text.x = element_text(size = 7), panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), strip.text = element_text(size = 12), axis.text.y = element_blank(),
        axis.title.y = element_blank(), legend.box = "horizontal") +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_x_discrete(labels = c("dagaa" = "Dagaa", "migebuka" = "Migebuka", "other_fish" = "Other Fish")) +
  facet_wrap(~ cluster, nrow = 2, 
             labeller = as_labeller(c("Overall North" = "Overall North", "Overall South" = "Overall South")))

```


```{r,  fig.cap='Primary source of fish eaten in the last week', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
    group_by(primary_source) %>%
    summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>%  filter(primary_source != "OTHER" & primary_source != "I DON'T KNOW") %>% drop_na() 

# Split data by clusters
village_data_cluster_1 <- tanganyika_survey %>%
  filter(village %in% cluster_1_villages) %>%
  group_by(primary_source) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%  
  filter(primary_source != "OTHER" & primary_source != "I DON'T KNOW") %>% 
  drop_na()

village_data_cluster_2 <- tanganyika_survey %>%
  filter(village %in% cluster_2_villages) %>%
  group_by(primary_source) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%  
  filter(primary_source != "OTHER" & primary_source != "I DON'T KNOW") %>% 
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the grouped bar chart with clusters
ggplot(village_data_combined, aes(x = reorder(primary_source, -proportion), y = proportion * 100, fill = reorder(primary_source, -proportion))) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(aes(
      label = paste0(round(proportion * 100, 1), "%"),
      y = pmin(proportion_upp * 100, 100) + 2), 
      position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Purchase", "Own Catch", "Received as Gift", "Bartered", "Borrowed")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

Fish consumption has changed in the past five years (Figure 19). Over two thirds of all households indicated that they eat less fish now. Approximately a fifth of households eat the same amount of fish as five years ago, and 12% of households stated that they eat more fish now. 

```{r,  fig.cap='Change in frequency of fish consumption over the last 5 years', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
    group_by(eat_changed) %>%
    summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>%  filter(eat_changed != "NOT SURE" & eat_changed != "I DON'T KNOW") %>% drop_na() 

# Split data by clusters
village_data_cluster_1 <- tanganyika_survey %>%
  filter(village %in% cluster_1_villages) %>%
  group_by(eat_changed) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%  
  filter(eat_changed != "NOT SURE" & eat_changed != "I DON'T KNOW") %>% 
  drop_na()

village_data_cluster_2 <- tanganyika_survey %>%
  filter(village %in% cluster_2_villages) %>%
  group_by(eat_changed) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%  
  filter(eat_changed != "NOT SURE" & eat_changed != "I DON'T KNOW") %>% 
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the grouped bar chart with clusters
ggplot(village_data_combined, aes(x = reorder(eat_changed, -proportion), y = proportion * 100, fill = reorder(eat_changed, -proportion))) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(aes(
      label = paste0(round(proportion * 100, 0), "%"),
      y = pmin(proportion_upp * 100, 100) + 2), 
      position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Eat Less Now", "Same as Before", "Eat More Now", "Bartered")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

Food shortages occurred amongst 62% of all households during the last 12 months (Figure 20). In all villages, half or more than half of the household experienced at least one food shortage over the past 12 months. Shortages were most frequent in Manda Uhuru, where 95% of households were affected. 

```{r, fig.cap='Proportion of food shortages experienced during the last 12 months at village level (%)', fig.align='center', out.width = '90%'}

village_data <- tanganyika_survey %>%
  group_by(village, worry_shortage) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(worry_shortage == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), worry_shortage) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(worry_shortage == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

village_data_yes <- village_data_yes %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(village_data_yes$village[village_data_yes$cluster == "Cluster 1"]),
        unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]))))

# Create the plot
ggplot(village_data_yes, aes(x = village, y = proportion * 100, group = worry_shortage, fill = worry_shortage)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 1), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size=8), 
    strip.text = element_blank(), 
    axis.title.x = element_blank(),  
    axis.text.y = element_blank(), 
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = NULL) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))

```

Primary reasons for food shortages experienced in the last 12 months include inadequate storage of food reserves (n = 14), increases in food prices (n = 12), financial strains related to a limited income and/or the rising costs of basic needs (n = 11), and challenges experienced due to a limited harvest season (n = 10). Inadequate food reserves have led to ongoing food insecurity among households; families sold their crops without setting aside sufficient reserves, whilst low crop yields depleted available stores. Other reasons for food shortages pertain to ineffective farming practices, the high costs and limited access of manure, a significant drop in crop sale prices, which adversely affected household income and the ability to cover living expenses. Seven households referred to the adverse impacts of climate change, expressing that severe flooding due to excessive rainfall caused major crop losses and asset damage. Cross-border trading of food resources was stated by one household as a concern, exacerbating limited food supplies as traders opt to export crops to neighboring countries (Democratic Republic of Congo). 

In terms of food shortages, the period between December 2023 and February 2024 appears to have been the worst for households among the survey population (Figure 21). Likewise, a higher frequency of food shortages during the months of May, June, and July 2024 also appeared to affect many households. Despite the frequency of food shortages, many households (70%) indicated that food availability was average or better than usual over the past year (Figure 22). However, food availability was worse than usual for 28% of all households. At village level, half the households in Mwinza expressed having worse food availability in the past year (Table 9). 

```{r, fig.cap='Monthly proportions of food shortages experienced over the past 12 months', fig.align='center', out.width = '90%'}
# Step 1: Clean and prepare the data
cleaned_data <- tanganyika_clean %>%
  mutate(food_shortage = str_split(food_shortage, " (?=\\w+\\.)")) %>%
  unnest(food_shortage) %>%
  mutate(
    month = str_extract(food_shortage, "\\b\\w+"),
    year = str_extract(food_shortage, "\\d{4}") %>% as.numeric()) %>%
  filter(!is.na(month), !is.na(year)) %>%
  mutate(month = factor(month, levels = month.name, ordered = TRUE),
         month_year = paste(month, year, sep = " ") %>% as.factor())

# Split data by clusters
shortage_data_cluster_1 <- cleaned_data %>%
  filter(village %in% cluster_1_villages) %>%
  mutate(food_shortage = str_split(food_shortage, " (?=\\w+\\.)")) %>%
  unnest(food_shortage) %>%
  mutate(
    month = str_extract(food_shortage, "\\b\\w+"),
    year = str_extract(food_shortage, "\\d{4}") %>% as.numeric()) %>%
  filter(!is.na(month), !is.na(year)) %>%
  mutate(month = factor(month, levels = month.name, ordered = TRUE),
         month_year = paste(month, year, sep = " ") %>% as.factor())

shortage_data_cluster_2 <- cleaned_data %>%
  filter(village %in% cluster_2_villages) %>%
  mutate(food_shortage = str_split(food_shortage, " (?=\\w+\\.)")) %>%
  unnest(food_shortage) %>%
  mutate(
    month = str_extract(food_shortage, "\\b\\w+"),
    year = str_extract(food_shortage, "\\d{4}") %>% as.numeric()) %>%
  filter(!is.na(month), !is.na(year)) %>%
  mutate(month = factor(month, levels = month.name, ordered = TRUE),
         month_year = paste(month, year, sep = " ") %>% as.factor())

# Create survey design for each cluster
shortage_design_cluster_1 <- shortage_data_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

shortage_design_cluster_2 <- shortage_data_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize data for each cluster
shortage_data_cluster_1_summary <- shortage_design_cluster_1 %>%
  group_by(month_year) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  ungroup()

shortage_data_cluster_2_summary <- shortage_design_cluster_2 %>%
  group_by(month_year) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  ungroup()

# Complete months and ensure the month_year column includes all months
complete_months <- c("November 2023", "December 2023",
                     "January 2024", "February 2024", "March 2024", 
                     "April 2024", "May 2024", "June 2024", 
                     "July 2024", "August 2024", "September 2024", "October 2024")

shortage_data_combined <- bind_rows(
  shortage_data_cluster_1_summary %>% mutate(cluster = "Overall North"),
  shortage_data_cluster_2_summary %>% mutate(cluster = "Overall South")
) %>%
  complete(month_year = complete_months, fill = list(count = 0, proportion = 0)) %>%
  mutate(month_year = factor(month_year, levels = complete_months, ordered = TRUE))

# Create the grouped bar chart with clusters
ggplot(shortage_data_combined, aes(x = month_year, y = proportion * 100, fill = month_year)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1), panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), axis.text.y = element_blank(), 
        axis.title.y = element_blank(), legend.position = "none") +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```


```{r, fig.cap='Changes in household food availability over the past 12 months', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
    group_by(food_availability) %>%
    summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% 
  filter(food_availability != "I DO NOT WANT TO ANSWER" & food_availability != "I DON'T KNOW") %>% drop_na() 

# Split data by clusters
village_data_cluster_1 <- tanganyika_survey %>%
  filter(village %in% cluster_1_villages) %>%
  group_by(food_availability) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>% 
  filter(food_availability != "I DO NOT WANT TO ANSWER" & food_availability != "I DON'T KNOW") %>%
  drop_na()

village_data_cluster_2 <- tanganyika_survey %>%
  filter(village %in% cluster_2_villages) %>%
  group_by(food_availability) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>% 
  filter(food_availability != "I DO NOT WANT TO ANSWER" & food_availability != "I DON'T KNOW") %>%
  drop_na()

# Combine the data from both clusters and add a 'cluster' column
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Plot for each cluster
ggplot(village_data_combined, aes(x = fct_relevel(food_availability, "BETTER", "AVERAGE", "WORSE", "NOT SURE"), 
                                  y = proportion * 100, fill = food_availability)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), 
                width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Better", "Average", "Worse", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

```{r}
food_data <- tanganyika_survey %>%
  group_by(village, food_availability) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>% ungroup()

proportion_table <- food_data %>%
  select(village, food_availability, proportion) %>%
  pivot_wider(
    names_from = food_availability,    
    values_from = proportion)

proportion_table <- proportion_table[, !colnames(proportion_table) %in% c("I DON'T KNOW", "I DO NOT WANT TO ANSWER")]

proportion_table <- proportion_table %>%
  select(-`NOT SURE`, everything(), `NOT SURE`)

# Rename columns for clarity
colnames(proportion_table) <- c("Village", "Average", "Better", "Worse", "Not Sure")

proportion_table <- proportion_table %>%
  mutate(across(c("Average", "Better", "Worse", "Not Sure"),
                ~ ifelse(is.na(.), "", paste0(round(. * 100, 0)))))

# Calculate the overall average for all villages combined
total_row <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Average` = survey_mean(food_availability == "AVERAGE", na.rm = TRUE) * 100,
    `Better` = survey_mean(food_availability == "BETTER", na.rm = TRUE) * 100,
    `Worse` = survey_mean(food_availability == "WORSE", na.rm = TRUE) * 100,
    `Not Sure` = survey_mean(food_availability == "NOT SURE", na.rm = TRUE) * 100) %>%
  mutate(
    `Average` = paste0(round(`Average`, 0)),
    `Better` = paste0(round(`Better`, 0)),
    `Worse` = paste0(round(`Worse`, 0)),
    `Not Sure` = paste0(round(`Not Sure`, 0))) %>%
  # Remove columns with "_se" in their names
  select(-contains("_se"))

# Add the "Total" row to the combined table
proportion_table <- bind_rows(proportion_table, total_row)
colnames(proportion_table) <- c("Village", "Average (%)", "Better (%)", "Worse (%)", "Not Sure (%)")

add_lot_link(caption = 'Changes in household food availability over the last 12 months at village level (%)')

# Create the flextable
proportion_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::width(width = 0.5)  
```

When viewed over the period of the last five years, the trend in food availability appears the same (Figure 23). Overall, 16% of households experience better food availability, 54% experience the same availability of food, and 28% of households express being worse off now. 

```{r, fig.cap='Change in household food availability over the last 5 years', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
    group_by(availability_changed) %>%
    summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>%  filter(availability_changed != "I DO NOT WANT TO ANSWER" & availability_changed != "I DON'T KNOW") %>% drop_na() 

# Split data by clusters
village_data_cluster_1 <- tanganyika_survey %>%
  filter(village %in% cluster_1_villages) %>%
  group_by(availability_changed) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  filter(availability_changed != "I DO NOT WANT TO ANSWER" & availability_changed != "I DON'T KNOW") %>%
  drop_na()

village_data_cluster_2 <- tanganyika_survey %>%
  filter(village %in% cluster_2_villages) %>%
  group_by(availability_changed) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  filter(availability_changed != "I DO NOT WANT TO ANSWER" & availability_changed != "I DON'T KNOW") %>%
  drop_na()

# Combine the data from both clusters and add a 'cluster' column
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Plot for each cluster
ggplot(village_data_combined, aes(x = fct_relevel(availability_changed, "BETTER NOW", "SAME", "WORSE NOW", "NOT  SURE"), 
                                  y = proportion * 100, fill = availability_changed)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Better Now", "Same", "Worse Now", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```


```{r,  fig.cap='Reasons for increase in household food availability', fig.align='center', out.width = '90%'}

# Expand the data and add cluster information
availability_reason_expanded <- tanganyika_clean %>% 
  select(hh_code, village, availability_reason, availability_changed, stype, fpc) %>%
  separate_rows(availability_reason, sep = "\\|") %>%
  mutate(availability_reason = trimws(availability_reason)) %>% 
  drop_na() %>%
  filter(availability_changed %in% c("BETTER NOW", "SAME")) %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Overall North", 
    village %in% cluster_2_villages ~ "Overall South", 
    TRUE ~ "Other"
  ))

# Create a survey design object
availability_reason_design <- availability_reason_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

options(survey.lonely.psu = "adjust")

# Summarize data for each cluster
availability_reason_data <- availability_reason_design %>%
  filter(!(availability_reason == "I DON'T KNOW")) %>%
  group_by(cluster, availability_reason) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
    total = survey_total(vartype = "ci", na.rm = TRUE), 
    n = unweighted(n())
  ) %>%
  ungroup()

# Create a grouped bar chart with clusters
ggplot(availability_reason_data, aes(x = reorder(availability_reason, -proportion), y = proportion * 100, fill = reorder(availability_reason, -proportion))) + 
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), 
                width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 1), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = "", y = "") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none",  # Remove the legend
        axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), 
        axis.title.y = element_blank()) +  
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("High fish availability", "Crops thrived", "Use of fertilizer", "Other reasons", "Low fish availability", "Crops destroyed by bad weather", "Employment availabilities", "Normal situation", "Lack of fertilizer", "Remittances sent")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster


```

The reasons for an increase in food availability vary (Figure 24). 33% of respondents attributed their increase in food availability to improvements in fish stocks. Reasons also pertained to agriculture, as 29% of respondents attributed the improvements to food availability to thriving crop harvests, whereas 19% of respondents linked it to the use of fertilizer applied to their fields. Interestingly, a small subset of respondents linked their improvement in food availability to decreases in fish availability or destroyed crops, this may perhaps be related to a diversification in income or simply a misunderstanding.

Diversification of income sources was stated as another reason as to why food availability had improved over the past year (n = 4). Households expressed that previously, their income was solely dependent on fishing, but now they have diversified their sources of income, such as (poultry) farming, improving their financial situation. Improved farming practices (n = 3), increases in agricultural productivity due to expanding land under cultivation (n = 2), improvements in business activities (n = 2), stabilized food prices  (n = 1), and improvements in personal life (n = 1) and financial support obtained (n = 1) include other reasons for which food availability has improved.

```{r,  fig.cap='Reasons for decrease in household food availability', fig.align='center', out.width = '90%'}
# Expand the data and add cluster information
availability_reason_expanded <- tanganyika_clean %>% 
  select(hh_code, village, availability_reason, availability_changed, stype, fpc) %>%
  separate_rows(availability_reason, sep = "\\|") %>%
  mutate(availability_reason = trimws(availability_reason)) %>% 
  drop_na() %>%
  filter(availability_changed == "WORSE NOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Overall North", 
    village %in% cluster_2_villages ~ "Overall South", 
    TRUE ~ "Other"
  ))

# Create a survey design object
availability_reason_design <- availability_reason_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize data for each cluster
availability_reason_data <- availability_reason_design %>%
  filter(!(availability_reason == "I DON'T KNOW")) %>%
  group_by(cluster, availability_reason) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
    total = survey_total(vartype = "ci", na.rm = TRUE), 
    n = unweighted(n())
  ) %>%
  ungroup()

# Create a grouped bar chart with clusters
ggplot(availability_reason_data, aes(x = reorder(availability_reason, -proportion), y = proportion * 100, fill = reorder(availability_reason, -proportion))) + 
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), 
                width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 1), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = "", y = "") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  # Remove the legend
    axis.text.x = element_text(angle = 45, hjust = 1), 
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    axis.text.y = element_blank(), 
    axis.title.y = element_blank()
  ) + 
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Crops destroyed\nby bad weather", "Low fish availability", "Other reasons", "Illness", "Crops damaged by wildlife", "Lack of fertilizer", "Crops destroyed by pests", "High fish availability", "Death of a family member", "Normal situation", "Remittances not sent", "Use of fertilizer", "Crops thrived", "Lack of employment")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster


```

The destruction of crops by bad weather and low fish availability were the two primary reasons for a decrease in household food availability (Figure 25). Crop damage could also be attributed to wildlife (8%) and pests (7%). Respondents also expressed other reasons and illness to have affected food availability negatively. 

Other reasons expressed for a decrease in food availability pertain to financial strains attributed to the lack of a stable income source, with household income falling short of daily expenses (n = 12). Furthermore, limited crop yields and a drop in crop sale prices, as well as a lack of available land for farming, the use of low-quality farming inputs and reliance on basic farming equipment contributed to the reasons related to agricultural productivity, which caused lower food availability. Two households provided responses related to fishing, stating that underinvestment in fishing practices has reduced its potential for high yield. The rising cost of fishing operations and a lack of adequate fishing equipment limit access to abundant fishing ground, as reaching distant waters now requires more advanced vessels.

</div>
\newpage

<!-- rust page -->
<div class ="section-rust">

## Governance and Participation

Overall, almost half of the households (41%) think that they can influence village government decisions (Table 10). This is significantly more than the 24% estimated by the 2011 Tuungane survey and signifies an improvement in local governance and participation. Looking at the village level, three quarters of respondents in Majengo Mapya felt they could not influence government decisions. 

```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(hh_influence) & hh_influence != "I DO NOT WANT TO ANSWER" & hh_influence != "NOT SURE") %>% 
  group_by(village, hh_influence) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
hh_influence_table <- summary_by_village %>%
  select(village, hh_influence, proportion) %>%
  pivot_wider(names_from = hh_influence, values_from = proportion)

# Rename columns for clarity
colnames(hh_influence_table) <- c("Village", "No", "Yes", "I don't know")

# Format the proportion table values as percentages with one decimal point and add % sign
hh_influence_table <- hh_influence_table %>%
  mutate(across(c("No", "Yes", "I don't know"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

# Calculate the overall average for all villages combined
total_row <- hh_influence_table %>%
  summarise(
    Village = "Overall",
    `No` = mean(as.numeric(sub("%", "", `No`)) / 100, na.rm = TRUE) * 100,
    `Yes` = mean(as.numeric(sub("%", "", `Yes`)) / 100, na.rm = TRUE) * 100,
    `I don't know` = mean(as.numeric(sub("%", "", `I don't know`)) / 100, na.rm = TRUE) * 100) %>%
  mutate(
    `No` = paste0(round(`No`, 0)),
    `Yes` = paste0(round(`Yes`, 0)),
    `I don't know` = paste0(round(`I don't know`, 0)))

# Calculate the overall average for all villages combined
total_row <- tanganyika_survey %>%
  filter(!is.na(hh_influence) & hh_influence != "I DO NOT WANT TO ANSWER" & hh_influence != "NOT SURE") %>%
  summarise(
    Village = "Overall",
    `No` = survey_mean(hh_influence == "NO", na.rm = TRUE) * 100,
    `Yes` = survey_mean(hh_influence == "YES", na.rm = TRUE) * 100,
    `I don't know` = survey_mean(hh_influence == "I DON'T KNOW", na.rm = TRUE) * 100) %>%
  mutate(
    `No` = paste0(round(`No`, 0)),
    `Yes` = paste0(round(`Yes`, 0)),
    `I don't know` = paste0(round(`I don't know`, 0))) %>%
  # Remove columns with "_se" in their names
  select(-contains("_se"))

# Add the "Total" row to the combined table
hh_influence_table <- bind_rows(hh_influence_table, total_row)
colnames(hh_influence_table) <- c("Village", "No (%)", "Yes (%)", "I don't know (%)")

add_lot_link(caption = 'Household influence on decisions made by the village government at village level (%)')

hh_influence_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit() %>%
  add_header_row(
    values = c("", "Influence on village government decisions"),
    colwidths = c(1, ncol(hh_influence_table) - 1)) %>%
  align(i = 1, align = "center", part = "header")
```

5% of all household respondents (n = 51) actively participate in the decision-making process about fisheries resources and livelihoods through attending various meetings and workshops. These activities include planning meetings, government meetings, BMU and village meetings, as well as public meetings. A further 3% of households (n = 27) indicated they contribute significantly to decision-making about fisheries resources and livelihoods by providing input and suggestions. Their involvement includes voicing opinions, offering ideas, and participating in discussions to ensure effective management and sustainable practices. 15 respondents suggested that following guidelines and regulations is a way of contributing to decision-making. By adhering to these rules, they ensure sustainable fishing practices and compliance with legal requirements. Other contributions to the decision-making around fisheries resources and livelihoods include involvement as representatives or community leaders (n = 6), encouraging sustainable fishing practices and safeguarding fish breeding zones in their communities through active engagement with BMU activities (n = 4), education and awareness (n = 6), policy enforcement (n = 4), and participation in patrols and conservation efforts (n = 3).

Respondents were asked whether anyone in their household is a member of a village organisation, such as a cooperative, a self-help group, a women’s group, or some other group (Figure 26). Although the affirmative responses were low overall (13%), group membership in villages such as Mtakuja (45%), Kichangani (26%), and Katenge (20%) was markedly higher.

```{r, fig.cap='Village organisation membership at village level (%)', fig.align='center', out.width = '90%'}

village_data <- tanganyika_survey %>%
  group_by(village, village_membership) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(village_membership == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), village_membership) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(village_membership == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

village_data_yes <- village_data_yes %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(village_data_yes$village[village_data_yes$cluster == "Cluster 1"]),
        unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]))))


# Create the plot
ggplot(village_data_yes, aes(x = village, y = proportion * 100, group = village_membership, fill = village_membership)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
 geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size=8), 
    strip.text = element_blank(), 
    axis.title.x = element_blank(),  
    axis.text.y = element_blank(),  
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = NULL) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))

```

Trust is vital in establishing relationships between different stakeholders and can be an apt indicator of good relations in local governance. Trust between local villagers and local government authorities was high, as 69% of respondents indicated that local authorities could be trusted always or most of the time. However, people expressed having less trust in people from neighbouring villages or even people from their own village. 40% of respondents indicated that people from neighbouring villages could rarely be trusted or never be trusted, this corresponded to 30% with regards to people in their own village.

```{r, fig.cap='An indication of trust in people from the same village, neigbouring villages, and the local government', fig.align='center', out.width = '90%'}

# Filter out "NEVER" and "I DON'T KNOW"
filtered_data <- tanganyika_clean %>%
  filter(
    !people_trusted %in% c("NOT SURE", "I DO NOT WANT TO ANSWER"),
    !nearby_trusted %in% c("NOT SURE", "I DO NOT WANT TO ANSWER"),
    !government_trusted %in% c("NOT SURE", "I DO NOT WANT TO ANSWER")
  )

# Add cluster information
filtered_data <- filtered_data %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Overall North", 
    village %in% cluster_2_villages ~ "Overall South", 
    TRUE ~ "Other"
  ))

# Reshape the data
trust_data <- filtered_data %>%
  pivot_longer(
    cols = c(people_trusted, nearby_trusted, government_trusted),
    names_to = "party",
    values_to = "trust"
  )

# Create a survey design
trust_design <- trust_data %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize proportions by cluster
trust_proportions <- trust_design %>%
  group_by(cluster, party, trust) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>%
  ungroup()

# Create the grouped bar chart
ggplot(trust_proportions, aes(x = party, y = proportion, fill = fct_relevel(trust, "CAN ALWAYS BE TRUSTED", "CAN MOSTLY BE TRUSTED", "NEUTRAL", "CAN RARELY BE TRUSTED", "CAN NEVER BE TRUSTED"))) +
  geom_bar(stat = "identity", position = "dodge", width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1), ymin = pmax(proportion_low, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  geom_text(aes(y = pmin(proportion_upp, 1) + 0.04, 
                label = scales::percent(proportion, accuracy = 1)),
            position = position_dodge(width = 0.95), size = 3) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = NULL, y = NULL, fill = "Frequency of Trust") +
  scale_fill_viridis(discrete = TRUE, option = "D",labels = c("CAN ALWAYS BE TRUSTED" = "Always Trusted",
                                          "CAN MOSTLY BE TRUSTED" = "Mostly Trusted",
                                          "NEUTRAL" = "Neutral",
                                          "CAN RARELY BE TRUSTED" = "Rarely Trusted",
                                          "CAN NEVER BE TRUSTED" = "Never Trusted")) +
  sea::theme_sea() +
  theme(
    legend.position = "bottom", 
    legend.direction = "horizontal",  
    legend.justification = "center", 
    axis.text.x = element_text(size = 10), 
    strip.text.x = element_text(size = 12, face = "bold"),  # Adjust facet titles
    axis.text.y = element_blank(),  
    axis.title.y = element_blank(), 
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    legend.box = "horizontal"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_x_discrete(labels = c(
    "government_trusted" = "Local government", 
    "nearby_trusted" = "People in nearby villages", 
    "people_trusted" = "People in own village"
  )) +
  facet_wrap(
    ~ cluster, 
    nrow = 2, 
    labeller = as_labeller(c("Overall North" = "Overall North", "Overall South" = "Overall South", "Other" = "Other Villages")))

```

Overall, attendance of public meetings to discuss topics such as village land-use planning, lake management and/or fisheries management was estimated at 41% (Table 11). This reflects the trend observed in Table 10 about household influence on village government decisions. Similarly, three quarters of respondents from Majengo Mapya did not attend any public meetings in the past year. 

```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(meeting_attendance) & meeting_attendance != "I DO NOT WANT TO ANSWER" & meeting_attendance != "NOT SURE") %>% 
  group_by(village, meeting_attendance) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
meeting_attendance_table <- summary_by_village %>%
  select(village, meeting_attendance, proportion) %>%
  pivot_wider(names_from = meeting_attendance, values_from = proportion)

# Rename columns for clarity
colnames(meeting_attendance_table) <- c("Village", "No", "Yes", "I don't know")

# Format the proportion table values as percentages with one decimal point and add % sign
meeting_attendance_table <- meeting_attendance_table %>%
  mutate(across(c("No", "Yes", "I don't know"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 1), "%"))))

add_lot_link(caption = 'Public meeting attendance in the last 12 months to discuss village land-use planning, lake management and/or fisheries management at village level (%)')

hh_influence_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit() %>%
  add_header_row(
    values = c("", "Public Meeting Attendance"),
    colwidths = c(1, ncol(hh_influence_table) - 1)) %>%
  align(i = 1, align = "center", part = "header")
```

Conflicts and/or disputes about fishing occur rarely, with two thirds of all household respondents stating that conflicts occur rarely or never (Figure 28). In total, 18% of respondents indicated that conflicts occur often. Conflicts occur most often in Manda Kerenge (32%), Manda Uhuru (30%), and Mtakuja (29%). Positively, in the past year, the frequency of conflicts has decreased in most villages (Figure 29). Only in Katenge are there more conflicts than there were 12 months ago, as was indicated by 60% of respondents from the village. 

```{r, fig.cap='Frequency of conflicts about fishing at village level (%)', fig.align='center', out.width = '90%'}
expanded <- tanganyika_clean %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other")) 

design <- expanded %>%
  as_survey_design(strata = stype, fpc = fpc) 

conflict_data <- design %>%
  filter(!is.na(disputes_conflicts) & disputes_conflicts != "I DO NOT WANT TO ANSWER") %>% 
  group_by(village, cluster, disputes_conflicts) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup() 

overall_cluster_data <- design %>%
  filter(disputes_conflicts != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, disputes_conflicts) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
conflict_data <- bind_rows(conflict_data, overall_cluster_data)

conflict_data <- conflict_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(conflict_data$village[conflict_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(conflict_data$village[conflict_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
conflict_data$disputes_conflicts <- factor(
  conflict_data$disputes_conflicts,
  levels = conflict_data %>%
    group_by(disputes_conflicts) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(disputes_conflicts))

ggplot(conflict_data, aes(x = village, y = proportion * 100, group = fct_relevel(disputes_conflicts, "OFTEN", "RARELY", "NEVER", "NOT SURE"), fill = fct_relevel(disputes_conflicts, "OFTEN", "RARELY", "NEVER", "NOT SURE"))) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = c("OFTEN" = "Often",
                                          "RARELY" = "Rarely",
                                          "NEVER" = "Never",
                                          "NOT SURE" = "Not Sure")) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
        axis.text.x = element_text(size = 7), strip.text = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), legend.box = 
        "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_y_continuous(labels = label_percent(scale = 1))+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))

```


```{r, fig.cap='Change in frequency of conflicts about fishing at village level (%)', fig.align='center', out.width = '90%'}
expanded <- tanganyika_clean %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other")) 

design <- expanded %>%
  as_survey_design(strata = stype, fpc = fpc) 

conflict_data <- design %>%
  filter(!is.na(more_less) & more_less != "I DO NOT WANT TO ANSWER") %>% 
  group_by(village, cluster, more_less) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- design %>%
  filter(more_less != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, more_less) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
conflict_data <- bind_rows(conflict_data, overall_cluster_data)

conflict_data <- conflict_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(conflict_data$village[conflict_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(conflict_data$village[conflict_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
conflict_data$more_less <- factor(
  conflict_data$more_less,
  levels = conflict_data %>%
    group_by(more_less) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(more_less))


ggplot(conflict_data, aes(x = village, y = proportion * 100, group = fct_relevel(more_less, "MORE", "SAME", "LESS", "NOT SURE"), fill = fct_relevel(more_less, "MORE", "SAME", "LESS", "NOT SURE"))) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = c("MORE" = "More",
                                          "SAME" = "Same",
                                          "LESS" = "Less",
                                          "NOT SURE" = "Not Sure")) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
        axis.text.x = element_text(size = 7), strip.text = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), legend.box = 
        "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_y_continuous(labels = label_percent(scale = 1))+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))

```

Approximately two thirds of all reasons for conflicts concern the closure of the lake to fishers or the conflicts surrounding the use of illegal fishing gear (Figure 30). Fishing in protected breeding areas and the catching of undersized fish also contributed to conflicts. 

```{r,  fig.cap='Reasons for conflict', fig.align='center', out.width = '90%'}

# Expand and classify data by clusters
conflict_reason_expanded <- tanganyika_clean %>% 
  select(hh_code, village, conflict_reason, stype, fpc) %>%
  separate_rows(conflict_reason, sep = "\\|") %>%
  mutate(conflict_reason = trimws(conflict_reason)) %>% 
  drop_na() %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
conflict_reason_design_cluster_1 <- conflict_reason_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design(strata = stype, fpc = fpc)

conflict_reason_design_cluster_2 <- conflict_reason_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarise for Cluster 1
conflict_reason_data_cluster_1 <- conflict_reason_design_cluster_1 %>%
  filter(!(conflict_reason == "I DON'T KNOW")) %>%
  group_by(conflict_reason) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  )

# Summarise for Cluster 2
conflict_reason_data_cluster_2 <- conflict_reason_design_cluster_2 %>%
  filter(!(conflict_reason == "I DON'T KNOW")) %>%
  group_by(conflict_reason) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  )

# Combine the two clusters' data
conflict_reason_data_combined <- bind_rows(
  conflict_reason_data_cluster_1 %>% mutate(cluster = "Overall North"),
  conflict_reason_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(conflict_reason_data_combined, aes(x = reorder(conflict_reason, -proportion), 
                                          y = proportion * 100, fill = reorder(conflict_reason, -proportion))) + 
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 1), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = "", y = "") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none",  # Remove the legend
        axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_blank(),  
        axis.title.y = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +  
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Closure of the lake", "Use of illegal fishing gear", 
                              "Fishing in protected breeding area", "Catching undersized fish", 
                              "Other reasons", "Private land boundaries", "Fishing in the National Park")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

Conflicts most commonly occurred with government authorities, among fishers, and between BMUs and fishers (Figure 31). Noticeably, in villages of the northern cluster, BMUs may be considered negligible as a conflict party, and conflicts occurred predominantly with government authorities and among fishers. In the southern cluster, however, half or more of all listed conflicts are said to occur between BMUs and fishers.

```{r,  fig.cap='Conflict parties at village level (%)', fig.align='center', out.width = '90%'}

conflict_parties_expanded <- tanganyika_clean %>% select(hh_code, village, conflict_parties, stype, fpc) %>%
  separate_rows(conflict_parties, sep = "\\|") %>%
  mutate(conflict_parties = trimws(conflict_parties)) %>% drop_na()  

conflict_parties_expanded <- conflict_parties_expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

conflict_parties_design <- conflict_parties_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

conflict_parties_data <- conflict_parties_design %>%
  group_by(village, cluster, conflict_parties) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- conflict_parties_design %>%
  filter(conflict_parties != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, conflict_parties) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
conflict_parties_data <- bind_rows(conflict_parties_data, overall_cluster_data)

conflict_parties_data <- conflict_parties_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(conflict_parties_data$village[conflict_parties_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(conflict_parties_data$village[conflict_parties_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
conflict_parties_data$conflict_parties <- factor(
  conflict_parties_data$conflict_parties,
  levels = conflict_parties_data %>%
    group_by(conflict_parties) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(conflict_parties))

ggplot(conflict_parties_data, aes(x = village, y = proportion * 100, group = conflict_parties, fill = conflict_parties)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = c("AMONG FISHERS" = "Among fishers", "AMONG LOCAL VILLAGERS" = "Among local villagers", "BMUS WITH FISHERS" = "BMUs with fishers", "I DON'T KNOW" = "I don't know", "LOCAL VILLAGERS WITH GOVERNMENT" = "With government", "LOCAL VILLAGERS WITH IMMIGRANTS" = "With immigrants", "LOCAL VILLAGERS WITH PEOPLE FROM OTHER VILLAGES" = "With people from other villages", "OTHER" = "Other")) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
        axis.text.x = element_text(size = 7), strip.text = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), legend.box = "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = label_percent(scale = 1))

```

The majority of conflicts are resolved in a fair manner (Figure 32). Once again, Katenge stands out as a vast majority of respondents do not believe that conflicts are resolved fairly (80%). Unfair conflict resolution also appears high in Izinga and Wampembe. In general, it appears that in the southern cluster of villages fair conflict resolution is higher than in the northern cluster. 

Other parties listed among which disputes or conflicts occur include fishers and fisheries officers (n = 17) and include reasons such as conflict over illegal fishing, disagreements over payments and equipment provision, and conflicts regarding the lake closure. Fishers also experience disputes with government (n = 10), including national government, Nkasi district government, and the government of Izinga village. Furthermore, bandits (n = 3) were also listed as a conflict party.

```{r, fig.cap='Fair conflict resolution at village level (%)', fig.align='center', out.width = '90%'}
expanded <- tanganyika_clean %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other")) 

design <- expanded %>%
  as_survey_design(strata = stype, fpc = fpc) 

conflict_data <- design %>%
  filter(!is.na(fair_resolution) & fair_resolution != "I DON'T KNOW") %>% 
  group_by(village, cluster, fair_resolution) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup() 

overall_cluster_data <- design %>%
  filter(fair_resolution!= "I DO NOT WANT TO ANSWER" & fair_resolution!= "I DON'T KNOW") %>%
  group_by(cluster, fair_resolution) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
conflict_data <- bind_rows(conflict_data, overall_cluster_data)

conflict_data <- conflict_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(conflict_data$village[conflict_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(conflict_data$village[conflict_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
conflict_data$fair_resolution <- factor(
  conflict_data$fair_resolution,
  levels = conflict_data %>%
    group_by(fair_resolution) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(fair_resolution))

ggplot(conflict_data, aes(x = village, y = proportion * 100, group = fct_relevel(fair_resolution, "YES", "NO", "NOT SURE"), fill = fct_relevel(fair_resolution, "YES", "NO", "NOT SURE"))) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = c("YES" = "Yes",
                                          "NO" = "No",
                                          "NOT SURE" = "Not Sure")) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
        axis.text.x = element_text(size = 7), strip.text = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), legend.box = 
        "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_y_continuous(labels = label_percent(scale = 1))+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))

```

Two respondents indicated that disputes between BMUs and fishers are formally resolved by involving law enforcement authorities. This usually involves reporting the issue to the local police station for investigation and resolution. One respondent highlighted the role of community gatherings in resolving conflicts. These gatherings provide a platform for fishers and BMUs to engage in open discussions and come to a consensus on how to address the issue. Another respondent mentioned that some conflicts do not escalate to a level requiring intervention. These are perceived as minor issues that do not cause significant harm and, as such, are often left unresolved.

Respondents were asked about who they thought to be an influential leader among their community, for instance a local leader whom they respect and who they think is good at raising awareness in their village about important communal issues (Figure 33). In response, political leaders (38%) and religious leaders (24%) were mentioned most commonly. Political party leaders, civil servants, and respected elders were also mentioned frequently. Of these influential leaders, 72% already occupied a village, ward, or regional government position (Figure 34). 

```{r,  fig.cap='Influential community leaders', fig.align='center', out.width = '90%'}
# Expand and classify data by clusters
influential_leaders_expanded <- tanganyika_clean %>% 
  select(hh_code, village, influential_leaders, stype, fpc) %>%
  separate_rows(influential_leaders, sep = "\\|") %>%
  mutate(influential_leaders = trimws(influential_leaders)) %>% 
  drop_na() %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
influential_leaders_design_cluster_1 <- influential_leaders_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design(strata = stype, fpc = fpc)

influential_leaders_design_cluster_2 <- influential_leaders_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarise for Cluster 1
influential_leaders_data_cluster_1 <- influential_leaders_design_cluster_1 %>%
  filter(!(influential_leaders == "I DON'T KNOW")) %>%
  group_by(influential_leaders) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  )

# Summarise for Cluster 2
influential_leaders_data_cluster_2 <- influential_leaders_design_cluster_2 %>%
  filter(!(influential_leaders == "I DON'T KNOW")) %>%
  group_by(influential_leaders) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  )

# Combine the two clusters' data
influential_leaders_data_combined <- bind_rows(
  influential_leaders_data_cluster_1 %>% mutate(cluster = "Overall North"),
  influential_leaders_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(influential_leaders_data_combined, aes(x = reorder(influential_leaders, -proportion), 
                                              y = proportion * 100, fill = reorder(influential_leaders, -proportion))) + 
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 1), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) +
  labs(x = "", y = "") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "none",  # Remove the legend
        axis.text.x = element_text(angle = 45, hjust = 1), axis.text.y = element_blank(),  
        axis.title.y = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +  
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Political Leaders", "Religious Leaders", "Political Party Leaders", 
                              "Civil Servants", "Respected Elders", "Fishing Equipment Owners", 
                              "Fishing Equipment Leaders", "Sports Leaders", "Fishing Equipment Repairers", 
                              "Witch Doctors", "Farmers", "Others")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```


```{r, fig.cap='Influential leaders currently involved in a village, ward, or regional government position at village level (%)', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
  group_by(village, leader_position) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(leader_position == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), leader_position) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(leader_position == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

village_data_yes <- village_data_yes %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(village_data_yes$village[village_data_yes$cluster == "Cluster 1"]),
        unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]))))

# Create the plot
ggplot(village_data_yes, aes(x = village, y = proportion * 100, group = leader_position, fill = leader_position)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 1), "%")), 
    position = position_dodge(width = 0.95), 
    vjust = -0.5, # Align the label with the specified y-coordinate
    size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size=8), 
    strip.text = element_blank(), 
    axis.text.y = element_blank(),  
    axis.title.x = element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title.y = element_blank()) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = NULL) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))
```

\newpage

<!-- rust page -->
<div class ="section-rust">

## Beach Management Units (BMU)

By establishing Beach Management Units (BMUs), villages are able to enact and enforce their own sustainable fishing regulations and protect fish breeding and nurseries zones. Awareness of BMUs was strikingly low in the northern villages, only a few households in Izinga, Mwinza, and Ng’anga had heard of BMUs (Figure 35). On the contrary, the majority of households in the southern village cluster had an awareness of BMUs in their village, overall this accounted for 83% household awareness of BMUs.

```{r, fig.cap='Household awareness of BMUs at village level (%)', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
  group_by(village, awareness_bmu) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  # Create a full dataset to keep village names, with NA for missing "YES" entries
  complete(tanganyika_survey$village, fill = list(proportion = NA, awareness_bmu = "NO"))

village_data <- village_data %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1", 
    village %in% cluster_2_villages ~ "Cluster 2", 
    TRUE ~ "Other"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(awareness_bmu == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), awareness_bmu) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(awareness_bmu == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

cluster_1_order <- c(
  "Izinga", "Kala", "Katenge", "Kilambo cha Mkolechi", 
  "Kizumbi", "Lyapinda", "Mpasa", "Mwinza", "Ng'anga", 
  "Tundu", "Wampembe", "Overall North")

# Adjust factor levels for villages in Cluster 1 and Cluster 2
village_data <- village_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        cluster_1_order,  # Use the specified order for Cluster 1
        setdiff(unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]), "Overall South"),
        "Overall South")))

ggplot(village_data, aes(x = village, y = proportion * 100, group = awareness_bmu, fill = awareness_bmu)) +
geom_bar(data = village_data_yes, stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    data = village_data_yes,
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    data = village_data_yes, 
    aes(y = pmin(proportion_upp, 1) * 100 + 2, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = 0, size = 3) + 
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size = 8), 
    strip.text = element_blank(), 
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),  
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()) + 
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = NULL) +
  geom_bar(data = filter(village_data, awareness_bmu == "NO"), 
           stat = "identity", 
           position = position_dodge(preserve = "single"), 
           width = 0.95, 
           fill = "white", 
           alpha = 0) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x")
```

Household participation in BMU activities mirrored the trend in BMU awareness, as a subset of households in all villages of the southern cluster had indicated participating in BMU activities in the last year. On average, 34% of southern households had participated in BMU activities as opposed to none in the northern cluster (Figure 36).

```{r, fig.cap='Household participation in BMU activities over the past 12 months at village level (%)', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
  group_by(village, BMU_activity) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  # Create a full dataset to keep village names, with NA for missing "YES" entries
  complete(tanganyika_survey$village, fill = list(proportion = NA, BMU_activity = "NO"))

village_data <- village_data %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1", 
    village %in% cluster_2_villages ~ "Cluster 2", 
    TRUE ~ "Other"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(BMU_activity == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), BMU_activity) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(BMU_activity == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

cluster_1_order <- c(
  "Izinga", "Kala", "Katenge", "Kilambo cha Mkolechi", 
  "Kizumbi", "Lyapinda", "Mpasa", "Mwinza", "Ng'anga", 
  "Tundu", "Wampembe", "Overall North")

# Adjust factor levels for villages in Cluster 1 and Cluster 2
village_data <- village_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        cluster_1_order,  # Use the specified order for Cluster 1
        setdiff(unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]), "Overall South"),
        "Overall South")))

ggplot(village_data, aes(x = village, y = proportion * 100, group = BMU_activity, fill = BMU_activity)) +
geom_bar(data = village_data_yes, stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    data = village_data_yes,
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    data = village_data_yes, 
    aes(y = pmin(proportion_upp, 1) * 100 + 2, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = 0, size = 3) + 
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size = 8), 
    strip.text = element_blank(), 
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),  
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()) + 
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = NULL) +
  geom_bar(data = filter(village_data, BMU_activity == "NO"), 
           stat = "identity", 
           position = position_dodge(preserve = "single"), 
           width = 0.95, 
           fill = "white", 
           alpha = 0) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x")

```

Overall, BMU membership in the southern village cluster is estimated at 31% of households (Figure 37). Household membership appears highest in Mtakuja (45%) and lowest in Majengo Mapya (17%). Despite 3% of households indicating that they are members of a BMU in Mwinza, it appears that across the whole northern village cluster no BMUs have been established to date. Across the southern cluster, 57% of BMUs are supported by the TNC Lake Tanganyika Project (Figure 38). This support is highest in Ntanganyika, Manda Uhuru, and Mkinga. Households in Isasa and Kalungu expressed having the least support provided by the TNC Lake Tanganyika Project. Overall, representation in the leadership of BMUs appeared equitable, as almost 90% of all household respondents indicated that women and youth made up part of the BMU leadership (Table 12).

```{r, fig.cap='BMU membership at village level (%)', fig.align='center', out.width = '90%'}

village_data <- tanganyika_survey %>%
  group_by(village, bmu_member) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  # Create a full dataset to keep village names, with NA for missing "YES" entries
  complete(tanganyika_survey$village, fill = list(proportion = NA, bmu_member = "NO"))

village_data <- village_data %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1", 
    village %in% cluster_2_villages ~ "Cluster 2", 
    TRUE ~ "Other"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(bmu_member == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), bmu_member) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(bmu_member == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

cluster_1_order <- c(
  "Izinga", "Kala", "Katenge", "Kilambo cha Mkolechi", 
  "Kizumbi", "Lyapinda", "Mpasa", "Mwinza", "Ng'anga", 
  "Tundu", "Wampembe", "Overall North")

# Adjust factor levels for villages in Cluster 1 and Cluster 2
village_data <- village_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        cluster_1_order,  # Use the specified order for Cluster 1
        setdiff(unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]), "Overall South"),
        "Overall South")))

ggplot(village_data, aes(x = village, y = proportion * 100, group = bmu_member, fill = bmu_member)) +
geom_bar(data = village_data_yes, stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    data = village_data_yes,
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    data = village_data_yes, 
    aes(y = pmin(proportion_upp, 1) * 100 + 2, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = 0, size = 3) + 
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size = 8), 
    strip.text = element_blank(), 
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),  
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()) + 
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = NULL) +
  geom_bar(data = filter(village_data, bmu_member == "NO"), 
           stat = "identity", 
           position = position_dodge(preserve = "single"), 
           width = 0.95, 
           fill = "white", 
           alpha = 0) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x")
```


```{r, fig.cap='TNC Lake Tanganyika Project supported BMUs at village level (%)', fig.align='center', out.width = '90%'}

village_data <- tanganyika_survey %>%
  group_by(village, tnc_support_bmu) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  # Create a full dataset to keep village names, with NA for missing "YES" entries
  complete(tanganyika_survey$village, fill = list(proportion = NA, tnc_support_bmu = "NO"))

village_data <- village_data %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1", 
    village %in% cluster_2_villages ~ "Cluster 2", 
    TRUE ~ "Other"))

# Filter for "YES" entries in borrow_status
village_data_yes <- village_data %>%
  filter(tnc_support_bmu == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), tnc_support_bmu) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(tnc_support_bmu == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

cluster_1_order <- c(
  "Izinga", "Kala", "Katenge", "Kilambo cha Mkolechi", 
  "Kizumbi", "Lyapinda", "Mpasa", "Mwinza", "Ng'anga", 
  "Tundu", "Wampembe", "Overall North")

# Adjust factor levels for villages in Cluster 1 and Cluster 2
village_data <- village_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        cluster_1_order,  # Use the specified order for Cluster 1
        setdiff(unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]), "Overall South"),
        "Overall South")))

ggplot(village_data, aes(x = village, y = proportion * 100, group = tnc_support_bmu, fill = tnc_support_bmu)) +
geom_bar(data = village_data_yes, stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    data = village_data_yes,
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    data = village_data_yes, 
    aes(y = pmin(proportion_upp, 1) * 100 + 2, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = 0, size = 3) + 
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size = 8), 
    strip.text = element_blank(), 
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),  
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()) + 
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = NULL) +
  geom_bar(data = filter(village_data, tnc_support_bmu == "NO"), 
           stat = "identity", 
           position = position_dodge(preserve = "single"), 
           width = 0.95, 
           fill = "white", 
           alpha = 0) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x")
```


```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(BMU_activity) & BMU_activity != "I DON'T KNOW") %>% 
  group_by(village, BMU_activity) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
BMU_activity_table <- summary_by_village %>%
  select(village, BMU_activity, proportion) %>%
  pivot_wider(names_from = BMU_activity, values_from = proportion)

# Rename columns for clarity
colnames(BMU_activity_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
BMU_activity_table <- BMU_activity_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(awareness_bmu) & awareness_bmu != "I DON'T KNOW") %>% 
  group_by(village, awareness_bmu) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
awareness_bmu_table <- summary_by_village %>%
  select(village, awareness_bmu, proportion) %>%
  pivot_wider(names_from = awareness_bmu, values_from = proportion)

# Rename columns for clarity
colnames(awareness_bmu_table) <- c("Village", "No", "Yes", "Not Sure")

# Format the proportion table values as percentages with one decimal point and add % sign
awareness_bmu_table <- awareness_bmu_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))


summary_by_village <- tanganyika_survey %>%
  filter(!is.na(bmu_member) & bmu_member != "I DON'T KNOW") %>% 
  group_by(village, bmu_member) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
bmu_member_table <- summary_by_village %>%
  select(village, bmu_member, proportion) %>%
  pivot_wider(names_from = bmu_member, values_from = proportion)

# Rename columns for clarity
colnames(bmu_member_table) <- c("Village", "No", "Not Sure", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
bmu_member_table <- bmu_member_table %>%
  mutate(across(c("No", "Yes"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(tnc_support_bmu) & tnc_support_bmu != "I DON'T KNOW") %>% 
  group_by(village, tnc_support_bmu) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
tnc_support_table <- summary_by_village %>%
  select(village, tnc_support_bmu, proportion) %>%
  pivot_wider(names_from = tnc_support_bmu, values_from = proportion)

# Rename columns for clarity
colnames(tnc_support_table) <- c("Village", "Yes", "Not Sure", "No")

# Format the proportion table values as percentages with one decimal point and add % sign
tnc_support_table <- tnc_support_table %>%
  mutate(across(c("Yes", "No", "Not Sure"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(bmu_women) & bmu_women != "I DON'T KNOW") %>% 
  group_by(village, bmu_women) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
bmu_women_table <- summary_by_village %>%
  select(village, bmu_women, proportion) %>%
  pivot_wider(names_from = bmu_women, values_from = proportion)

# Rename columns for clarity
colnames(bmu_women_table) <- c("Village", "Not Sure", "Yes", "No")

# Format the proportion table values as percentages with one decimal point and add % sign
bmu_women_table <- bmu_women_table %>%
  mutate(across(c("Yes", "No", "Not Sure"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(bmu_youth) & bmu_youth != "I DON'T KNOW") %>% 
  group_by(village, bmu_youth) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
bmu_youth_table <- summary_by_village %>%
  select(village, bmu_youth, proportion) %>%
  pivot_wider(names_from = bmu_youth, values_from = proportion)

# Rename columns for clarity
colnames(bmu_youth_table) <- c("Village", "Not Sure", "Yes", "No")

# Format the proportion table values as percentages with one decimal point and add % sign
bmu_youth_table <- bmu_youth_table %>%
  mutate(across(c("Yes", "No", "Not Sure"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

combined_table <- awareness_bmu_table %>%
  select(Village, `Aware of BMUs` = Yes) %>%  
  left_join(BMU_activity_table %>% select(Village, `Has participated in BMU activity` = Yes), by = "Village") %>%
  left_join(bmu_member_table %>% select(Village, `Member of BMU` = Yes), by = "Village") %>%
  left_join(tnc_support_table %>% select(Village, `BMU is TNC supported` = Yes), by = "Village") %>%
  left_join(bmu_women_table %>% select(Village, `Women in BMU leadership` = Yes), by = "Village") %>%
  left_join(bmu_youth_table %>% select(Village, `Youth in BMU` = Yes), by = "Village") 

total_row <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Aware of BMUs` = survey_mean(awareness_bmu == "YES", na.rm = TRUE) * 100,
    `Has participated in BMU activity` = survey_mean(BMU_activity == "YES", na.rm = TRUE) * 100,
    `Member of BMU` = survey_mean(bmu_member == "YES", na.rm = TRUE) * 100,
    `BMU is TNC supported` = survey_mean(tnc_support_bmu == "YES", na.rm = TRUE) * 100,
    `Women in BMU leadership` = survey_mean(bmu_women == "YES", na.rm = TRUE) * 100,
    `Youth in BMU` = survey_mean(bmu_youth == "YES", na.rm = TRUE) * 100,) %>%
  mutate(
    `Aware of BMUs` = paste0(round(`Aware of BMUs`, 0)),
    `Has participated in BMU activity` = paste0(round(`Has participated in BMU activity`, 0)),
    `Member of BMU` = paste0(round(`Member of BMU`, 0)),
    `BMU is TNC supported` = paste0(round(`BMU is TNC supported`, 0)),
    `Women in BMU leadership` = paste0(round(`Women in BMU leadership`, 0)),
    `Youth in BMU` = paste0(round(`Youth in BMU`, 0))) %>% select(-contains("_se"))


# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)
colnames(combined_table) <- c("Village", "Aware of BMUs (%)", "Participated in BMU activity (%)", "BMU member (%)", "TNC supported BMU (%)", "Women in BMU leadership (%)", "Youth in BMU leadership (%)")

add_lot_link(caption = 'BMU awareness and participation at village level (%)')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()
```

Respondents indicated that they frequently engage in activities organized by the BMU (Figure 39). Common activities that are engaged in frequently include raising awareness around conserving Lake Tanganyika, as well as the monitoring of illegal fishing practices, monitoring use of illegal fishing gear, and performing BMU patrols. Fish catch data is also collected frequently and aids in managing local fisheries resources. Meetings to discuss fisheries management across the BMUs appear to be held occasionally.

```{r, fig.cap='An indication of frequency for BMU activities', fig.align='center', out.width = '90%'}
# Mapping activity levels to numeric values
activity_mapping <- c(
  "NEVER" = 1,
  "RARELY" = 2,
  "FREQUENTLY" = 3
)

# Specified activity columns
activity_columns <- c(
  "meetings", "patrolling", "illegal_fishing", "illegal_gears", 
  "raise_awareness", "collect_fees", "engage_activities", 
  "forms_revenue", "collect_data", "other_activity"
)

# Convert columns to numeric using the mapping
tanganyika_clean <- tanganyika_clean %>%
  mutate(across(all_of(activity_columns), ~ recode(., !!!activity_mapping)))

# Reshape data to long format
activity_long <- tanganyika_clean %>%
  pivot_longer(
    cols = all_of(activity_columns), 
    names_to = "Activity", 
    values_to = "Frequency"
  ) %>%
  filter(!is.na(Frequency))

# Add cluster classification
activity_long <- activity_long %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Overall North",
    village %in% cluster_2_villages ~ "Overall South",
    TRUE ~ "Other"
  ))

# Create survey design for Cluster 1
activity_design_cluster_1 <- activity_long %>%
  filter(cluster == "Overall North") %>%
  group_by(stype) %>%
  mutate(fpc = ifelse(n() > first(fpc), n(), first(fpc))) %>%
  ungroup() %>%
  as_survey_design(strata = stype, fpc = fpc)

# Create survey design for Cluster 2
activity_design_cluster_2 <- activity_long %>%
  filter(cluster == "Overall South") %>%
  group_by(stype) %>%
  mutate(fpc = ifelse(n() > first(fpc), n(), first(fpc))) %>%
  ungroup() %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize for Cluster 1
aggregate_activity_cluster_1 <- activity_design_cluster_1 %>%
  group_by(Activity) %>%
  summarise(
    mean_activity_value = survey_mean(Frequency, vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(cluster = "Overall North")

# Summarize for Cluster 2
aggregate_activity_cluster_2 <- activity_design_cluster_2 %>%
  group_by(Activity) %>%
  summarise(
    mean_activity_value = survey_mean(Frequency, vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(cluster = "Overall South")

# Combine the results from both clusters
aggregate_activity_combined <- bind_rows(aggregate_activity_cluster_1, aggregate_activity_cluster_2)

# Plotting activity values with clusters separated
ggplot(aggregate_activity_combined, aes(
  x = reorder(Activity, -mean_activity_value), 
  y = mean_activity_value, 
  fill = Activity
)) +
  geom_bar(stat = "identity", width = 0.75) +
  labs(x = NULL, y = NULL) +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(
    legend.position = "none", 
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 12, face = "bold"), # Add bold, larger cluster titles
    legend.box = "horizontal"
  ) +
  scale_y_continuous(
    limits = c(0, 3), 
    breaks = 1:3, 
    labels = c("Never", "Rarely", "Frequently")
  ) +
  scale_x_discrete(labels = c(
    "Raising awareness about\nconserving the lake", 
    "Controlling illegal\nfishing", 
    "Controlling illegal\nfishing gear", 
    "Patrolling", 
    "Collecting data", 
    "Meetings", 
    "Collect fees or levies\nfrom outside fishers", 
    "Engage in\nbusiness activities", 
    "Collect other\nforms of revenue", 
    "Other activities"
  )) +
  facet_wrap(~ cluster, nrow = 2, scales = "free_y", strip.position = "top") 
```

Three quarters of all households believed that their BMU had good leaders in place (Figure 40). In most instances (85%), respondents indicated that election procedures to choose BMU leaders were fair (Figure 41). Only 8% believed that BMU leaders were elected unfairly. Furthermore, two thirds of people indicated that there is good trust and collaboration between their BMU and government authorities in the management of fishing resources (Figure 42). 

```{r, fig.cap='Do you think the BMU has good leaders?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
village_data_expanded <- tanganyika_survey %>%
  filter(!is.na(good_leaders) & good_leaders != "I DON'T KNOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
village_data_design_cluster_1 <- village_data_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

village_data_design_cluster_2 <- village_data_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
village_data_cluster_1 <- village_data_design_cluster_1 %>%
  group_by(good_leaders) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
village_data_cluster_2 <- village_data_design_cluster_2 %>%
  group_by(good_leaders) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(village_data_combined, aes(x = fct_relevel(good_leaders, "YES", "NO", "NOT SURE"), 
                                  y = proportion * 100, fill = good_leaders)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```


```{r, fig.cap='Were BMU leaders elected or chosen fairly?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
leaders_elected_expanded <- tanganyika_survey %>%
  filter(!is.na(leaders_elected) & leaders_elected != "I DON'T KNOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
leaders_elected_design_cluster_1 <- leaders_elected_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

leaders_elected_design_cluster_2 <- leaders_elected_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
leaders_elected_cluster_1 <- leaders_elected_design_cluster_1 %>%
  group_by(leaders_elected) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
leaders_elected_cluster_2 <- leaders_elected_design_cluster_2 %>%
  group_by(leaders_elected) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
leaders_elected_combined <- bind_rows(
  leaders_elected_cluster_1 %>% mutate(cluster = "Overall North"),
  leaders_elected_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(leaders_elected_combined, aes(x = fct_relevel(leaders_elected, "YES", "NO", "NOT SURE"), 
                                    y = proportion * 100, fill = leaders_elected)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```


```{r, fig.cap='Indication of trust and collaboration between BMU and the Government in the management of fishing resources', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
trust_collaboration_expanded <- tanganyika_survey %>%
  filter(!is.na(trust_collaboration) & trust_collaboration != "I DON'T KNOW" & 
         trust_collaboration != "I DO NOT WANT TO ANSWER" & trust_collaboration != "NOT SURE") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
trust_collaboration_design_cluster_1 <- trust_collaboration_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

trust_collaboration_design_cluster_2 <- trust_collaboration_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
trust_collaboration_cluster_1 <- trust_collaboration_design_cluster_1 %>%
  group_by(trust_collaboration) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
trust_collaboration_cluster_2 <- trust_collaboration_design_cluster_2 %>%
  group_by(trust_collaboration) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
trust_collaboration_combined <- bind_rows(
  trust_collaboration_cluster_1 %>% mutate(cluster = "Overall North"),
  trust_collaboration_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(trust_collaboration_combined, aes(x = fct_relevel(trust_collaboration, "GOOD", "AVERAGE", "BAD"), 
                                        y = proportion * 100, fill = trust_collaboration)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Good", "Average", "Bad")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

Few power struggles and/or conflicts of interest occur between village leaders and the BMU (21%; Table 13). However, despite a very limited sample size, respondents from Izinga (n = 2) and Mwinza (n = 1) indicated that power struggles and/or conflicts of interest were ubiquitous among village leaders and the BMU. In the instances that conflicts of interest occur, they are predominantly solved internally, by negotiating with one another (51%). Only in 17% of instances do parties go to the village government to discuss matters and fewer (8%) go to the ward or district government to discuss matters. 

```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(conflcit_interest) & conflcit_interest != "I DON'T KNOW" & conflcit_interest != "I DO NOT WANT TO ANSWER") %>% 
  group_by(village, conflcit_interest) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
conflict_table <- summary_by_village %>%
  select(village, conflcit_interest, proportion) %>%
  pivot_wider(names_from = conflcit_interest, values_from = proportion)

# Rename columns for clarity
colnames(conflict_table) <- c("Village", "No", "Not Sure", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
conflict_table <- conflict_table %>%
  mutate(across(c("No", "Not Sure", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

expanded <- tanganyika_clean %>% select(hh_code, village, conflict_resolution, stype, fpc) %>%
  separate_rows(conflict_resolution, sep = "\\|") %>%
  mutate(conflict_resolution = trimws(conflict_resolution)) %>% drop_na()  

expanded <- expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

expanded <- expanded %>%
  mutate(conflict_resolution = ifelse(
    conflict_resolution %in% c("THERE ARE NO CONFLICTS BETWEEN BMUs and FISHERS", "I DON'T KNOW"),
    "OTHER",
    conflict_resolution
  ))

design <- expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

conflict_resolution_data <- design %>%
  filter(!(village == "Mwinza")) %>% # Mwinza only contains one priamry sampling unit (PSU)
  group_by(village, cluster, conflict_resolution) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
proportion_table <- conflict_resolution_data %>%
  select(village, conflict_resolution, proportion) %>%
  pivot_wider(
    names_from = conflict_resolution,   
    values_from = proportion   # Fill with the proportion values
  )

# Rename columns for clarity
colnames(proportion_table) <- c("Village", "Go to ward or district government", "Negotiate with each other", "Do nothing", "Go to village government", "Other")

# Format the proportion table values as percentages with one decimal point and add % sign, leave NA as blank
proportion_table <- proportion_table %>%
  mutate(across(c("Go to ward or district government", "Negotiate with each other", "Do nothing", "Go to village government", "Other"),
                ~ ifelse(is.na(.), "", paste0(round(. * 100, 0)))))

combined_table <- conflict_table %>%
  select(Village, `Conflicts of interest indicated` = Yes) %>%
  left_join(proportion_table %>% select(Village, `Go to ward or district government`, `Negotiate with each other`, `Go to village government`, `Do nothing`, Other), by = "Village") 

# Calculate the overall average for all villages combined
total_row_coi <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Conflicts of interest indicated` = survey_mean(conflcit_interest == "YES", na.rm = TRUE) * 100) %>%
  mutate(
    `Conflicts of interest indicated` = paste0(round(`Conflicts of interest indicated`, 0))) %>% select(-contains("_se"))

# Calculate the overall average for all villages combined
total_row_resolution <- design %>%
  filter(!(village == "Mwinza")) %>%
  filter(!is.na(conflict_resolution) & conflict_resolution != "I DO NOT WANT TO ANSWER" & conflict_resolution != "I DON'T KNOW") %>%
  summarise(
    Village = "Overall",
    `Go to ward or district government` = survey_mean(conflict_resolution == "GO TO WARD OR DISTRICT GOVERNMENT", na.rm = TRUE) * 100,
    `Negotiate with each other` = survey_mean(conflict_resolution == "NEGOTIATE WITH EACH OTHER", na.rm = TRUE) * 100,
    `Go to village government` = survey_mean(conflict_resolution == "GO TO VILLAGE GOVERNMENT", na.rm = TRUE) * 100,
    `Do nothing` = survey_mean(conflict_resolution == "DO NOTHING", na.rm = TRUE) * 100,
    `Other` = survey_mean(conflict_resolution == "OTHER", na.rm = TRUE) * 100) %>%
  mutate(
    `Go to ward or district government` = paste0(round(`Go to ward or district government`, 0)),
    `Negotiate with each other` = paste0(round(`Negotiate with each other`, 0)),
    `Go to village government` = paste0(round(`Go to village government`, 0)),
    `Do nothing` = paste0(round(`Do nothing`, 0)),
    `Other` = paste0(round(`Other`, 0))) %>%
  # Remove columns with "_se" in their names
  select(-contains("_se"))

total_row <- left_join(total_row_coi, total_row_resolution, by = "Village") %>%
  select(Village, `Conflicts of interest indicated`, `Go to ward or district government`, `Negotiate with each other`, `Go to village government`, `Do nothing`, Other)


# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)
colnames(combined_table) <- c("Village", "Conflicts of interest (%)", "Go to ward or district government (%)", "Negotiate with each other (%)", "Go to village government (%)", "Do nothing (%)", "Other (%)")

add_lot_link(caption = 'Conflict of interest and/or power struggle between village leaders and BMU (%)')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white") %>%
  flextable::autofit() %>%
  add_header_row(
    values = c("", "", "How do people in your village try to solve the conflict?"),
    colwidths = c(1, 1, ncol(combined_table) - 2)) %>%
  align(i = 1, align = "left", part = "header")

```

Where BMUs are established, in the southern cluster of villages, almost two thirds of BMUs have written bylaws in place, which is an indication for good governance and fisheries management (Figure 43). At village level, approximately half or more of respondents in each village indicated that written bylaws were in place in their BMU. In response to the statement “BMU bylaws are being followed”, the majority of households responded in agreement (85%). Only 13% of households either disagreed or strongly disagreed to the statement (Figure 44). 

```{r, fig.cap='Written BMU bylaws at village level (%)', fig.align='center', out.width = '90%'}
village_data <- tanganyika_survey %>%
  group_by(village, bmu_bylaws) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), 
            total = survey_total(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>%
  # Create a full dataset to keep village names, with NA for missing "YES" entries
  complete(tanganyika_survey$village, fill = list(proportion = NA, bmu_bylaws = "NO"))

village_data <- village_data %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1", 
    village %in% cluster_2_villages ~ "Cluster 2", 
    TRUE ~ "Other"
  ))

# Filter for "YES" entries in bmu_bylaws for plotting
village_data_yes <- village_data %>%
  filter(bmu_bylaws == "YES")

cluster_summary <- tanganyika_survey %>%
  group_by(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2"), bmu_bylaws) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())) %>%
  mutate(
    village = case_when(
      cluster == "Cluster 1" ~ "Overall North",
      cluster == "Cluster 2" ~ "Overall South")) %>%
  filter(bmu_bylaws == "YES")

# Add cluster-level and total summaries to the data
village_data_yes <- bind_rows(village_data_yes, cluster_summary)

cluster_1_order <- c(
  "Izinga", "Kala", "Katenge", "Kilambo cha Mkolechi", 
  "Kizumbi", "Lyapinda", "Mpasa", "Mwinza", "Ng'anga", 
  "Tundu", "Wampembe", "Overall North")

# Adjust factor levels for villages in Cluster 1 and Cluster 2
village_data <- village_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        cluster_1_order,  # Use the specified order for Cluster 1
        setdiff(unique(village_data_yes$village[village_data_yes$cluster == "Cluster 2"]), "Overall South"),
        "Overall South")))

# Create the plot
ggplot(village_data, aes(x = village, y = proportion * 100, group = bmu_bylaws, fill = bmu_bylaws)) +
  
  # Bar plot for "YES" entries
  geom_bar(data = village_data_yes, stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(
    data = village_data_yes,
    aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100),
    position = position_dodge(preserve = "single", width = 0.95), 
    width = 0.1) +
  geom_text(
    data = village_data_yes, 
    aes(y = pmin(proportion_upp, 1) * 100 + 2, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = 0, size = 3) + 
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  scale_fill_manual(values = SEA_palette) +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(
    legend.position = "none",  
    axis.text.x = element_text(size = 8), 
    strip.text = element_blank(), 
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.x = element_blank(),  
    axis.title.y = element_blank(),
    panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = NULL) +
  
  # Make sure villages with "NO" still show space on the x-axis
  geom_bar(data = filter(village_data, bmu_bylaws == "NO"), 
           stat = "identity", 
           position = position_dodge(preserve = "single"), 
           width = 0.95, 
           fill = "white", 
           alpha = 0) + 
  facet_wrap(~cluster, ncol = 1, scales = "free_x")
```


```{r, fig.cap='Statement: BMU bylaws are being followed', fig.align='center', out.width = '90%'}

# Expand the data with cluster classification
bylaws_followed_expanded <- tanganyika_survey %>%
  filter(!is.na(bylaws_followed) & bylaws_followed != "97 I DON'T KNOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
bylaws_followed_design_cluster_1 <- bylaws_followed_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

bylaws_followed_design_cluster_2 <- bylaws_followed_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
bylaws_followed_cluster_1 <- bylaws_followed_design_cluster_1 %>%
  group_by(bylaws_followed) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
bylaws_followed_cluster_2 <- bylaws_followed_design_cluster_2 %>%
  group_by(bylaws_followed) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
bylaws_followed_combined <- bind_rows(
  bylaws_followed_cluster_1 %>% mutate(cluster = "Overall North"),
  bylaws_followed_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(bylaws_followed_combined, aes(x = fct_relevel(bylaws_followed, 
                                                    "1 STRONGLY DISAGREE", "2 DISAGREE", 
                                                    "3 NEUTRAL", "4 AGREE", "5 STRONGLY AGREE"), 
                                    y = proportion * 100, fill = bylaws_followed)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

When asked whether BMUs have improved fishing practices, 45% of households responded in agreement and a further 23% of households strongly agreed (Figure 45). Few people felt neutral about the impact of BMUs on fishing practices, but 28% of respondents either disagreed or disagreed strongly. 

```{r, fig.cap='Do you think the BMU has improved fishing practices?', fig.align='center', out.width = '90%'}

# Expand the data with cluster classification
bmu_practice_expanded <- tanganyika_survey %>%
  filter(!is.na(bmu_practice) & bmu_practice != "97 I DON'T KNOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
bmu_practice_design_cluster_1 <- bmu_practice_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

bmu_practice_design_cluster_2 <- bmu_practice_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
bmu_practice_cluster_1 <- bmu_practice_design_cluster_1 %>%
  group_by(bmu_practice) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
bmu_practice_cluster_2 <- bmu_practice_design_cluster_2 %>%
  group_by(bmu_practice) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
bmu_practice_combined <- bind_rows(
  bmu_practice_cluster_1 %>% mutate(cluster = "Overall North"),
  bmu_practice_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(bmu_practice_combined, aes(x = fct_relevel(bmu_practice, 
                                                 "1 STRONGLY DISAGREE", "2 DISAGREE", 
                                                 "3 NEUTRAL", "4 AGREE", "5 STRONGLY AGREE"), 
                                 y = proportion * 100, fill = bmu_practice)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

### BMU Challenges

A major challenge faced by BMUs pertains to illegal fishing practices, including the use of unauthorized nets and fishing in protected areas, which was listed by 11% (n = 106) of all households surveyed. According to respondents, BMUs often face resistance from fishers when enforcing regulations, which undermines conservation efforts. A significant proportion of respondents, 9% of all households surveyed (n = 91), also indicated that BMUs face challenges related to a lack of resources and equipment. These include a lack of patrol boats, safety gear, and insufficient funds for operations such as fuel and maintenance. 6% (n = 64)  of all households regarded insecurity, violence, and threats as a significant challenge faced by BMU members. These include physical attacks from illegal fishers, threats to their lives, and verbal abuse from community members. Furthermore, conflict issues were highlighted as a significant challenge faced by BMU (n = 34). These conflicts arise between BMU members and fishers, as well as between BMU and the community and include a lack of understanding, opposition from locals, and disputes during enforcement activities. Several respondents (n = 29) identified inadequate training and knowledge as a significant challenge, including a lack of education about the purpose and regulations of BMUs, insufficient knowledge on conservation, and the absence of regularly held training sessions.

Other challenges faced by BMUs include corruption and bribery of BMU leaders and law enforcement officers (n = 14), a lack of collaboration between the BMU, local authorities, and other stakeholders (n = 13), compliance and law enforcement issues (n = 24), administrative challenges (n = 7), financial constraints (n = 13),  environmental challenges (n = 6), interference from local administrations and government officials on BMU activities (n = 5), poor working conditions (n = 3), as well as a lack of support from relevant stakeholders (n = 3). Together, these challenges hamper the effectiveness and compromise the integrity of BMU activities and enforcement of fishing regulations. 

In response to the question “How could the BMU be improved?”, many household respondents (n = 77) emphasized the need to enhance the capacity of BMUs through better tools, infrastructure, and financial resources. Suggestions included improvements to working equipment, funding mechanisms, and infrastructure development to ensure BMUs can perform their duties effectively and sustainably. Respondents (n = 84) also emphasized the need for increased training, education, and capacity building for BMUs, their members, and the fishermen they interact with. The focus should be on providing continuous education on sustainable fishing practices, environmental conservation, and the roles of BMUs. Additionally, many respondents stressed the importance of regular workshops, seminars, and training programs to empower both leaders and members to better manage the fisheries resources and enforce the laws effectively. In order to improve operational efficiency and accountability within BMUs, 35 respondents highlighted the provision of sufficient security, tools, and resources to enhance patrol efforts. Key issues include the provision of safety measures, modern equipment for patrols (i.e. boats, weapons, and protective gear), and formal recognition of BMUs to ensure better enforcement of fisheries laws.

Other improvements to BMUs related to improved governance, stronger leadership, and fairness in BMU operations (n = 34). Suggestions emphasized eliminating corruption and favoritism, enforcing equity among fishers, and strengthening BMUs with better resources and support from the government. Respondents also highlighted the need for clear legal frameworks, fair enforcement of fishing regulations, and collaborative strategies to combat illegal fishing practices. Furthermore, responses provided by 24 households emphasized the importance of fostering strong relationships between BMUs, government officials, and local communities. Participants suggested that BMUs should work collaboratively with fishers, local government authorities, and environmental organizations to address challenges and improve resource management. Many highlighted the need for government support and greater cooperation between BMUs and stakeholders to enhance the effectiveness of fishing regulations and conservation efforts.



</div>

## Fishing

```{r,  fig.cap='Type of fishing boats used at village level', fig.align='center', out.width = '90%'}
boat_type_expanded <- tanganyika_clean %>% select(hh_code, village, boat_type, stype, fpc) %>%
  separate_rows(boat_type, sep = "\\|") %>%
  mutate(boat_type = trimws(boat_type)) %>% drop_na()  

boat_type_expanded <- boat_type_expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

boat_type_design <- boat_type_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

boat_type_data <- boat_type_design %>%
  group_by(village, cluster, boat_type) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- boat_type_design %>%
  filter(boat_type != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, boat_type) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
boat_type_data <- bind_rows(boat_type_data, overall_cluster_data)

boat_type_data <- boat_type_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(boat_type_data$village[boat_type_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(boat_type_data$village[boat_type_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
boat_type_data$boat_type <- factor(
  boat_type_data$boat_type,
  levels = boat_type_data %>%
    group_by(boat_type) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(boat_type))

ggplot(boat_type_data, aes(x = village, y = proportion * 100, group = boat_type, fill = boat_type)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
    position = position_dodge(width = 0.8), width = 0.25) +
  # geom_text(aes(
  #     label = paste0(round(proportion * 100, 0)),
  #     y = pmin(proportion_upp * 100, 100) + 2),
  #     position = position_dodge(width = 0.8), vjust = 0, size = 3) +
  guides(fill = guide_legend(title = NULL, nrow = 1, reverse = FALSE)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D",labels = c(
      "CANOE BOAT" = "Canoe", 
      "CANOE WITHOUT MOTOR" = "Canoe without engine",
      "ENGINE BOAT" = "Engine boat",
      "LARGE BOAT WITH ENGINE" = "Large boat with engine",
      "LARGE BOAT WITHOUT ENGINE" = "Large boat without engine",
      "DON’T FISH FROM BOAT" = "Don't fish from boat")) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
    # axis.text.y = element_blank(),  # Remove y-axis labels
    # axis.ticks.y = element_blank(),  # Remove y-axis ticks
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    strip.text = element_blank(), 
    legend.box = "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = label_percent(scale = 1))

```


```{r,  fig.cap='Relative importance of different fish species at village level', fig.align='center', out.width = '90%'}
fish_importance_vars <- c("dagaa_importance", "migebuka_importance", "kungura_importance", "ngege_importance", "kuhe_importance", "sangara_importance")

fish_importance_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(fish_importance_vars), names_to = "Fish_Species", values_to = "Importance") %>% mutate(Importance = case_when(is.na(Importance) ~ 0, TRUE ~ 7 - Importance)) %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other")) %>% 
  mutate(Fish_Species = str_replace(Fish_Species, "_importance", "") %>% str_to_title())

strat_design <- fish_importance_long %>%
  as_survey_design(strata = stype, fpc = fpc)

aggregate_fish_importance <- strat_design %>%
  group_by(village, cluster, Fish_Species) %>%
  summarise(
    mean_importance = survey_mean(Importance, vartype = "ci", na.rm = TRUE),
    mean_importance_low = survey_mean(Importance, vartype = "ci", na.rm = TRUE, level = 0.95)[["ci_low"]],
    mean_importance_upp = survey_mean(Importance, vartype = "ci", na.rm = TRUE, level = 0.95)[["ci_upp"]],
    n = unweighted(n())
  ) %>%
  ungroup() %>%
  group_by(village) %>%
  mutate(
    total_importance = sum(mean_importance, na.rm = TRUE), # Total importance per village
    mean_importance_percent = (mean_importance / total_importance) * 100, # Relative percentage
    mean_importance_percent_low = (mean_importance_low / total_importance) * 100, # Lower bound of percentage
    mean_importance_percent_upp = (mean_importance_upp / total_importance) * 100  # Upper bound of percentage
  )

# Add a "Total" group to the data
total_data <- strat_design %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_importance = survey_mean(Importance, vartype = "ci", na.rm = TRUE),
    mean_importance_low = survey_mean(Importance, vartype = "ci", na.rm = TRUE, level = 0.95)[["ci_low"]],
    mean_importance_upp = survey_mean(Importance, vartype = "ci", na.rm = TRUE, level = 0.95)[["ci_upp"]],
    total = survey_total(Importance, vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(
    village = "Overall",
    cluster = "Overall",
    total_importance = sum(mean_importance, na.rm = TRUE),
    mean_importance_percent = (mean_importance / total_importance) * 100,
    mean_importance_percent_low = (mean_importance_low / total_importance) * 100,
    mean_importance_percent_upp = (mean_importance_upp / total_importance) * 100
  ) %>%
  ungroup()

# Combine the total_data with the original treatment_data
aggregate_fish_importance <- bind_rows(aggregate_fish_importance, total_data)

aggregate_fish_importance <- aggregate_fish_importance %>%
  mutate(cluster = case_when(
    cluster == "Overall" ~ "Cluster 2", TRUE ~ cluster))

aggregate_fish_importance <- aggregate_fish_importance %>%
  mutate(village = reorder(village, -mean_importance_percent))  # Reorder villages based on proportion

# Reorder treatment_method_dry based on average proportion for each method
aggregate_fish_importance$Fish_Species <- factor(
  aggregate_fish_importance$Fish_Species,
  levels = aggregate_fish_importance %>%
    group_by(Fish_Species) %>%
    summarise(avg_proportion = mean(mean_importance_percent, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(Fish_Species))

# Plot using relative percentages
ggplot(aggregate_fish_importance, aes(x = village, y = mean_importance_percent, group = Fish_Species, fill = Fish_Species)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymin = mean_importance_percent_low, ymax = mean_importance_percent_upp),
                position = position_dodge(width = 0.95), width = 0.2) +
  guides(fill = guide_legend(title = NULL, nrow = 1, reverse = FALSE)) +
  labs(x = "Village", y = "Relative Importance (%)") +
  sea::scale_fill_sea_discrete() +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
    # axis.text.y = element_blank(),  # Remove y-axis labels
    # axis.ticks.y = element_blank(),  # Remove y-axis ticks
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    strip.text = element_blank(), 
    legend.box = "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = label_percent(scale = 1))


```


```{r, fig.cap='Self-assessment of fisheries resource management over the past five years', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
fisheries_resources_expanded <- tanganyika_survey %>%
  filter(!is.na(fisheries_resources) & fisheries_resources != "I DO NOT WANT TO ANSWER") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
fisheries_resources_design_cluster_1 <- fisheries_resources_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

fisheries_resources_design_cluster_2 <- fisheries_resources_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
fisheries_resources_cluster_1 <- fisheries_resources_design_cluster_1 %>%
  group_by(fisheries_resources) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
fisheries_resources_cluster_2 <- fisheries_resources_design_cluster_2 %>%
  group_by(fisheries_resources) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
fisheries_resources_combined <- bind_rows(
  fisheries_resources_cluster_1 %>% mutate(cluster = "Overall North"),
  fisheries_resources_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(fisheries_resources_combined, aes(x = fct_relevel(fisheries_resources, 
                                                       "VERY BAD", "BAD", 
                                                       "NEUTRAL", "GOOD", "VERY GOOD"), 
                                       y = proportion * 100, fill = fisheries_resources)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Very Bad", "Bad", "Neutral", "Good", "Very Good")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(rights_access) & rights_access != "I DON'T KNOW") %>% 
  group_by(village, rights_access) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
rights_access_table <- summary_by_village %>%
  select(village, rights_access, proportion) %>%
  pivot_wider(names_from = rights_access, values_from = proportion)

# Rename columns for clarity
colnames(rights_access_table) <- c("Village", "No", "Not Sure", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
rights_access_table <- rights_access_table %>%
  mutate(across(c("No", "Not Sure", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))


summary_by_village <- tanganyika_survey %>%
  filter(!is.na(security_rights) & security_rights != "I DON'T KNOW") %>% 
  group_by(village, security_rights) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
security_rights_table <- summary_by_village %>%
  select(village, security_rights, proportion) %>%
  pivot_wider(names_from = security_rights, values_from = proportion)

# Rename columns for clarity
colnames(security_rights_table) <- c("Village", "No", "Not Sure", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
security_rights_table <- security_rights_table %>%
  mutate(across(c("No", "Not Sure", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))


summary_by_village <- tanganyika_survey %>%
  filter(!is.na(decision_making) & decision_making != "I DON'T KNOW") %>% 
  group_by(village, decision_making) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
decision_making_table <- summary_by_village %>%
  select(village, decision_making, proportion) %>%
  pivot_wider(names_from = decision_making, values_from = proportion)

# Rename columns for clarity
colnames(decision_making_table) <- c("Village", "No", "Yes", "Not Sure")

# Format the proportion table values as percentages with one decimal point and add % sign
decision_making_table <- decision_making_table %>%
  mutate(across(c("No", "Not Sure", "Yes"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

combined_table <- rights_access_table %>%
  select(Village, `Rights to access and use fishery resources are being upheld by regulatory and/or communal systems` = Yes) %>%  
  left_join(security_rights_table %>% select(Village, `Happy with the current security of your rights over fisheries resources` = Yes), by = "Village") %>%
  left_join(decision_making_table %>% select(Village, `Involved in decision-making processes regarding fisheries resources` = Yes), by = "Village")

total_row <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Rights to access and use fishery resources are being upheld by regulatory and/or communal systems` = survey_mean(rights_access == "YES", na.rm = TRUE) * 100,
    `Happy with the current security of your rights over fisheries resources` = survey_mean(security_rights == "YES", na.rm = TRUE) * 100,
    `Involved in decision-making processes regarding fisheries resources` = survey_mean(decision_making == "YES", na.rm = TRUE) * 100) %>%
  mutate(
    `Rights to access and use fishery resources are being upheld by regulatory and/or communal systems` = paste0(round(`Rights to access and use fishery resources are being upheld by regulatory and/or communal systems`, 0)),
    `Happy with the current security of your rights over fisheries resources` = paste0(round(`Happy with the current security of your rights over fisheries resources`, 0)),
    `Involved in decision-making processes regarding fisheries resources` = paste0(round(`Involved in decision-making processes regarding fisheries resources`, 0))) %>% select(-contains("_se"))


# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)
colnames(combined_table) <- c("Village", "Rights to access and use fishery resources are being upheld by regulatory and/or communal systems (%)", "Happy with the current security of your rights over fisheries resources (%)", "Involved in decision-making processes regarding fisheries resources (%)")

add_lot_link(caption = 'Access rights, security, and decision making around fisheries resources at village level (%)')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()
```


```{r, fig.cap='Satisfaction with involvement in decision-making around fisheries resources?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
satisfaction_involvement_expanded <- tanganyika_survey %>%
  filter(!is.na(satisfaction_involvement)) %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
satisfaction_involvement_design_cluster_1 <- satisfaction_involvement_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

satisfaction_involvement_design_cluster_2 <- satisfaction_involvement_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
satisfaction_involvement_cluster_1 <- satisfaction_involvement_design_cluster_1 %>%
  group_by(satisfaction_involvement) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
satisfaction_involvement_cluster_2 <- satisfaction_involvement_design_cluster_2 %>%
  group_by(satisfaction_involvement) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
satisfaction_involvement_combined <- bind_rows(
  satisfaction_involvement_cluster_1 %>% mutate(cluster = "Overall North"),
  satisfaction_involvement_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(satisfaction_involvement_combined, aes(x = fct_relevel(satisfaction_involvement, 
                                                           "HAPPY", "NOT HAPPY"), 
                                               y = proportion * 100, fill = satisfaction_involvement)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Happy", "Not Happy")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```


```{r, fig.cap='An indication of the relationship with fisheries extension officers', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
relationship_officer_expanded <- tanganyika_survey %>%
  filter(!is.na(relationship_officer) & relationship_officer != "NOT SURE" & relationship_officer != "I DO NOT WANT TO ANSWER") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
relationship_officer_design_cluster_1 <- relationship_officer_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

relationship_officer_design_cluster_2 <- relationship_officer_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
relationship_officer_cluster_1 <- relationship_officer_design_cluster_1 %>%
  group_by(relationship_officer) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
relationship_officer_cluster_2 <- relationship_officer_design_cluster_2 %>%
  group_by(relationship_officer) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
relationship_officer_combined <- bind_rows(
  relationship_officer_cluster_1 %>% mutate(cluster = "Overall North"),
  relationship_officer_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(relationship_officer_combined, aes(x = fct_relevel(relationship_officer, "GOOD", "AVERAGE", "BAD"), 
                                          y = proportion * 100, fill = relationship_officer)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Good", "Average", "Bad")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

Amongst 14% (n = 144) of all household respondents, no challenges concerning fisheries extension officers were mentioned. In contrast, 7% (n = 65) of all household listed abuse of power by fisheries extension officers as a key issue. Respondents mentioned that officers often apply unfair tactics, such as confiscating fishing gear or boats over minor infractions or expired licenses and imposing fines without clear justification. Fisheries extension officers also use intimidation, force, and harassment, making it difficult for fishers to comply peacefully. Unfair enforcement of fishing regulations was listed by a further 36 households. For instance, license payments are demanded from individuals who aren't even fishers, while allowing illegal fishers to operate freely. Those fishers with valid licenses may also be harassed and fined unnecessarily.

Issues pertaining to delays in fishing license processing affected 25 respondents. These mentioned that despite paying fees, they often receive receipts instead of licenses, with delays in issuance. The process for obtaining a license is thought to be confusing and fishers are sometimes forced to pay multiple times without receiving proper documentation. High license fees also pose an issue (n = 20), as officers charge large amounts for licenses and impose heavy fines, which are often unrelated to the severity of offenses. The fees vary periodically, sometimes increasing significantly, and many fishers struggle to afford them. Five respondents revealed that fishers continue to pay for licenses during closure of the fishing season, leading to under utilization of the license. The mismatch between the license duration and the actual fishing time results in an unfair distribution of costs and benefits.

Limited transparency and community engagement result in weak relationships, insufficient involvement in decision-making processes, and inadequate information sharing (n = 21). However, a lack of compliance with regulations by fishermen also contributes to challenges (n = 25), leading to the issuance of fines, confiscation of equipment, and restricted access to fishing areas, creating further difficulties for enforcement. A further 13 respondents stated that fisheries officers fail to meet their core responsibilities, including the effective regulation of fishing gear, with some accused of misusing funds meant for fishing equipment.


```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(awareness_reserves) & awareness_reserves != "I DON'T KNOW") %>% 
  group_by(village, awareness_reserves) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
awareness_reserves_table <- summary_by_village %>%
  select(village, awareness_reserves, proportion) %>%
  pivot_wider(names_from = awareness_reserves, values_from = proportion)

# Rename columns for clarity
colnames(awareness_reserves_table) <- c("Village", "Yes", "No", "Not Sure")

# Format the proportion table values as percentages with one decimal point and add % sign
awareness_reserves_table <- awareness_reserves_table %>%
  mutate(across(c("No", "Not Sure", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))


summary_by_village <- tanganyika_survey %>%
  filter(!is.na(purpose_reserves) & purpose_reserves != "I DON'T KNOW") %>% 
  group_by(village, purpose_reserves) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
purpose_reserves_table <- summary_by_village %>%
  select(village, purpose_reserves, proportion) %>%
  pivot_wider(names_from = purpose_reserves, values_from = proportion)

# Rename columns for clarity
colnames(purpose_reserves_table) <- c("Village", "Yes", "No", "Not Sure")

# Format the proportion table values as percentages with one decimal point and add % sign
purpose_reserves_table <- purpose_reserves_table %>%
  mutate(across(c("No", "Not Sure", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))


summary_by_village <- tanganyika_survey %>%
  filter(!is.na(opinion_reserves) & opinion_reserves != "I DON'T KNOW") %>% 
  group_by(village, opinion_reserves) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
opinion_reserves_table <- summary_by_village %>%
  select(village, opinion_reserves, proportion) %>%
  pivot_wider(names_from = opinion_reserves, values_from = proportion)

# Rename columns for clarity
colnames(opinion_reserves_table) <- c("Village", "No", "Not Sure", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
opinion_reserves_table <- opinion_reserves_table %>%
  mutate(across(c("No", "Not Sure", "Yes"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

combined_table <- awareness_reserves_table %>%
  select(Village, `Aware of fish reserves` = Yes) %>%  
  left_join(purpose_reserves_table %>% select(Village, `Aware of fish reserve purpose` = Yes), by = "Village") %>%
  left_join(opinion_reserves_table %>% select(Village, `Think fish reserves are a good idea` = Yes), by = "Village")

# Calculate the overall average for all villages combined
total_row <- combined_table %>%
  summarise(
    Village = "Overall",
    `Aware of fish reserves` = mean(as.numeric(sub("%", "", `Aware of fish reserves`)) / 100, na.rm = TRUE) * 100,
    `Aware of fish reserve purpose` = mean(as.numeric(sub("%", "", `Aware of fish reserve purpose`)) / 100, na.rm = TRUE) * 100,
    `Think fish reserves are a good idea` = mean(as.numeric(sub("%", "", `Think fish reserves are a good idea`)) / 100, na.rm = TRUE) * 100) %>%
  mutate(
    `Aware of fish reserves` = paste0(round(`Aware of fish reserves`, 0)),
    `Aware of fish reserve purpose` = paste0(round(`Aware of fish reserve purpose`, 0)),
    `Think fish reserves are a good idea` = paste0(round(`Think fish reserves are a good idea`, 0)))

# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)
colnames(combined_table) <- c("Village", "Aware of fish reserves (%)", "Aware of fish reserve purpose (%)", "Think fish reserves are a good idea (%)")

add_lot_link(caption = 'Awareness and acceptance of fish reserves at village level (%)')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()

```

The implementation of fish reserves received both positive and negative feedback. Positively, 24% of all household respondents (n = 237) stated that fish reserves are useful because they ensure that fish have adequate time and space to breed without disturbance, helping to preserve and boost fish stocks, support sustainable fishing, and secure long-term availability of fish resources for communities. 5% (n = 53) mentioned that fish reserves are beneficial as they ensure sustainability and abundance of fish for future generations. They also mentioned that fish reserves allow conserving fish stocks for both current and future use, reducing overfishing, and providing long-term benefits for the environment and society. The size of fishes was a consideration too, as 32 respondents highlighted that reserves help prevent the capture of immature fish, thus providing a safe space for fish to grow, and ultimately supporting better fishing practices by increasing the yield of fully grown fish. Another 2% (n = 17) of household respondents said they supported sustainable fishing practices, stating that fish reserves prevent overfishing, safeguard aquatic ecosystems, and ensure that fish populations remain available to the community. Arguments voicing the positive benefits of fish reserves also pertained to financial benefits, as 20 household respondents believed fish reserves generate reliable revenue for the local government, contribute to community development through projects funded by fishing fees, and help ensure fish populations increase and are preserved for better economic returns.

Negative opinions on the implementation of fish reserves were varied but limited and pertained to a perceived lack of impact from fish reserves (n = 9), concerns about location and boundaries (n = 8), a loss of income and fish (n = 4), and the idea that the sheer size of Lake Tanganyika aids in self-regulating fish population (n = 3). People that reported a perceived lack of impact from fish reserves argued that fish were reproducing even before the reserves were established, and natural systems were intact. Some shared that fish migrate to reserves, causing scarcity in non-reserve areas, and despite the reserves, fish remain scarce. Those with concerns about the location and boundaries of fish reserves highlighted that within the large areas designated as reserves, the fishing zones are small, and the number of fishers is high. They also criticized the location of the reserves, saying that fish do not remain in those areas, but simply pass through. Financial concerns pertained to the idea that fish reserves lead to a lack of fish, which tend to escape to the reserves, making fishing more difficult in the remaining areas. The fees imposed on fishers in conjunction with short fishing periods, disrupt livelihoods as communities depend on the lake for income. In Manda Kerenge, one respondent shared that households in the village feel heavily restricted because of the intervention.


```{r, fig.cap='At the moment, do you think the current number of fish in the lake is sufficient to meet the fishing, food, and livelihood needs of the community?', fig.align='center', out.width = '90%'}

# Expand the data with cluster classification
sustainability_population_expanded <- tanganyika_survey %>%
  filter(!is.na(sustainability_population) & sustainability_population != "I DON'T KNOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
sustainability_population_design_cluster_1 <- sustainability_population_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

sustainability_population_design_cluster_2 <- sustainability_population_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
sustainability_population_cluster_1 <- sustainability_population_design_cluster_1 %>%
  group_by(sustainability_population) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
sustainability_population_cluster_2 <- sustainability_population_design_cluster_2 %>%
  group_by(sustainability_population) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
sustainability_population_combined <- bind_rows(
  sustainability_population_cluster_1 %>% mutate(cluster = "Overall North"),
  sustainability_population_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(sustainability_population_combined, aes(x = fct_relevel(sustainability_population, "YES", "NO", "NOT SURE"), 
                                               y = proportion * 100, fill = sustainability_population)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

```{r, fig.cap='In the future, do you think there will be sufficient fish for the communities?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
sufficiency_fish_expanded <- tanganyika_survey %>%
  filter(!is.na(sufficiency_fish) & sufficiency_fish != "I DON'T KNOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
sufficiency_fish_design_cluster_1 <- sufficiency_fish_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

sufficiency_fish_design_cluster_2 <- sufficiency_fish_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
sufficiency_fish_cluster_1 <- sufficiency_fish_design_cluster_1 %>%
  group_by(sufficiency_fish) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
sufficiency_fish_cluster_2 <- sufficiency_fish_design_cluster_2 %>%
  group_by(sufficiency_fish) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
sufficiency_fish_combined <- bind_rows(
  sufficiency_fish_cluster_1 %>% mutate(cluster = "Overall North"),
  sufficiency_fish_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(sufficiency_fish_combined, aes(x = fct_relevel(sufficiency_fish, "YES", "NO", "NOT SURE"), 
                                      y = proportion * 100, fill = sufficiency_fish)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

A number of participants (n = 91) highlighted that the protection of fish breeding areas and the establishment of dedicated fish conservation zones are crucial for ensuring sufficient fish populations in the future. Furthermore, the importance of government regulations in managing fishing practices, including enforcing seasonal closures and preventing illegal fishing, was emphasized by 66 household respondents. Participants suggested that measures such as restricting fishing during breeding seasons and maintaining control over illegal fishing practices are crucial for sustaining fish populations. Furthermore, 29 households indicated that fish are able to reproduce naturally, especially during the rainy season, leading to an increase in their numbers. Respondents mentioned that because fish currently breed in large numbers, they will continue to do so in future. Furthermore, a number of respondents (n = 8) indicated that they believe continued effective management to contribute to the future conservation of fish stocks in Lake Tanganyika, with three respondents stating that BMUs play a crucial role.

“BMU wanajitahidi kutunza maeneo ya hifadhi ya samaki”

Concerns about the future availability of fish in Lake Tanganyika were widely expressed. A significant number of respondents (n = 55) highlighted the prevalence of illegal fishing as a critical challenge to fish populations and sustainability. They expressed concerns about the destructive impact of illegal practices, which disrupt fish breeding grounds and lead to overfishing. Some respondents (n = 11) expressed concern about the growing amount of fishing gear being used. They believe that the abundance of fishing tools, especially modern equipment, is contributing to overfishing and a significant decline in fish populations. Furthermore, 34 respondents addressed an increased use of illegal fishing gear as a concern. According to them, this equipment catches too many fish, including undersized ones, which threatens fish growth and reproduction. Fishing pressure was further addressed by respondents (n = 13) highlighting concerns about the growing number of fishers, which they believe is contributing to a decline in fish populations.


```{r, fig.cap='Type of fishing gear used at village level (%)', fig.align='center', out.width = '90%'}
fishing_gear_expanded <- tanganyika_clean %>% select(hh_code, village, fishing_gear, stype, fpc) %>%
  separate_rows(fishing_gear, sep = "\\|") %>%
  mutate(fishing_gear = trimws(fishing_gear)) %>% drop_na()  

fishing_gear_expanded <- fishing_gear_expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

fishing_gear_design <- fishing_gear_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

fishing_gear_data <- fishing_gear_design %>%
  group_by(village, cluster, fishing_gear) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- fishing_gear_design %>%
  filter(fishing_gear != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, fishing_gear) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
fishing_gear_data <- bind_rows(fishing_gear_data, overall_cluster_data)

fishing_gear_data <- fishing_gear_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(fishing_gear_data$village[fishing_gear_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(fishing_gear_data$village[fishing_gear_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
fishing_gear_data$fishing_gear <- factor(
  fishing_gear_data$fishing_gear,
  levels = fishing_gear_data %>%
    group_by(fishing_gear) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(fishing_gear))

ggplot(fishing_gear_data, aes(x = village, y = proportion * 100, group = fishing_gear, fill = fishing_gear)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
    position = position_dodge(width = 0.8), width = 0.25) +
  guides(fill = guide_legend(title = NULL, nrow = 2, reverse = FALSE)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = function(labels) str_to_title(str_to_lower(labels))) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
    # axis.text.y = element_blank(),  # Remove y-axis labels
    # axis.ticks.y = element_blank(),  # Remove y-axis ticks
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    strip.text = element_blank(), 
    legend.box = "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))+
  scale_y_continuous(labels = label_percent(scale = 1))

```

Other types of fishing gear listed by fishers include long lines, hooks, nets, as well as torches/lights, presumably for use at night. In one instance, diving equipment was mentioned.

```{r, fig.cap='Seasonal targeting of fish species over the past five years', fig.align='center', out.width = '90%'}
# Define target type variables
target_type_vars <- c("dagaa_season", "migebuka_season", "kungura_season", 
                      "ngege_season", "kuhe_season", "sangara_season")

# Pivot longer and clean Fish_Species names
target_type_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_vars), 
               names_to = "Fish_Species", 
               values_to = "Season") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_season", "") %>% str_to_title())

# Consolidate and clean `Season` values
target_type_long <- target_type_long %>%
  mutate(
    Season = case_when(
      str_detect(Season, "ALL SEASONS") & str_detect(Season, "RAINY SEASON") ~ "ALL SEASONS",
      str_detect(Season, "ALL SEASONS") & str_detect(Season, "DRY SEASON") ~ "ALL SEASONS",
      str_detect(Season, "RAINY SEASON") & str_detect(Season, "DRY SEASON") ~ "ALL SEASONS",
      Season == "I DON'T KNOW" ~ NA_character_,  
      TRUE ~ Season))

# Expand the data with cluster classification
target_type_long_expanded <- target_type_long %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey design for each cluster
target_type_design_cluster_1 <- target_type_long_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design(strata = stype, fpc = fpc)

target_type_design_cluster_2 <- target_type_long_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize by Fish_Species and Season for Cluster 1
aggregate_target_type_cluster_1 <- target_type_design_cluster_1 %>%
  group_by(Fish_Species, Season) %>%
  summarise(mean_season = survey_mean(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>%
  ungroup()

# Summarize by Fish_Species and Season for Cluster 2
aggregate_target_type_cluster_2 <- target_type_design_cluster_2 %>%
  group_by(Fish_Species, Season) %>%
  summarise(mean_season = survey_mean(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>%
  ungroup()

# Combine the two clusters' data
aggregate_target_type_combined <- bind_rows(
  aggregate_target_type_cluster_1 %>% mutate(cluster = "Overall North"),
  aggregate_target_type_cluster_2 %>% mutate(cluster = "Overall South")
)

# Calculate percentages and handle totals
aggregate_target_type_combined <- aggregate_target_type_combined %>%
  filter(!is.na(Season) & Season != "NONE") %>% 
  group_by(Fish_Species, cluster) %>%
  mutate(
    total_season = sum(mean_season, na.rm = TRUE), # Total importance per Fish_Species
    mean_season_percent = (mean_season / total_season) * 100, # Relative percentage
    mean_season_percent_low = (mean_season_low / total_season) * 100,  # Lower bound of percentage
    mean_season_percent_upp = (mean_season_upp / total_season) * 100   # Upper bound of percentage
  ) %>%
  ungroup()

# Plotting
ggplot(aggregate_target_type_combined, aes(x = Fish_Species, y = mean_season_percent, group = Season, fill = Season)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymin = mean_season_percent_low, ymax = mean_season_percent_upp),
                position = position_dodge(width = 0.95), width = 0.2) +
  geom_text(aes(y = pmin(mean_season_percent_upp, 100) + 2, 
                label = scales::percent(mean_season_percent / 100, accuracy = 1)),
            position = position_dodge(width = 0.95), size = 3) +
  labs(x = NULL, y = NULL) +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D",labels = function(labels) str_to_title(str_to_lower(labels))) +
  sea::theme_sea() + 
  theme(legend.position = "bottom", 
        legend.direction = "horizontal", 
        legend.justification = "center", 
        axis.text.x = element_text(size = 10),
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        strip.text = element_text(size = 12, face = "bold"),  # Increase font size for facet titles
        legend.box = "horizontal") + 
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  facet_wrap(~ cluster, nrow = 2, labeller = labeller(cluster = c("Overall North" = "Overall North", "Overall South" = "Overall South")))  # Custom facet labels

```

```{r}
# Convert time_input to duration in seconds
tanganyika_time <- tanganyika_survey %>%
  filter(!is.na(time_input)) %>%
  mutate(
    time_seconds = as.numeric(hms(sub("\\..*", "", time_input))),
    time_hours = time_seconds / 3600)

# Categorize travel times
tanganyika_time <- tanganyika_time %>%
  mutate(
    time_category = case_when(
      time_hours < 2 ~ "<2 hours",
      time_hours < 6 ~ "<6 hours",
      time_hours < 10 ~ "<10 hours",
      TRUE ~ ">10 hours"))

summary_table <- tanganyika_time %>%
  group_by(village) %>%
  summarise(
    `Less than 2 hrs` = paste0(round(mean(time_category == "<2 hours") * 100, 0)),
    `Less than 6 hrs` = paste0(round(mean(time_category == "<6 hours") * 100, 0)),
    `Less than 10 hrs` = paste0(round(mean(time_category == "<10 hours") * 100, 0)),
    `More than 10 hrs` = paste0(round(mean(time_category == ">10 hours") * 100, 0)),
    `Mean time (hrs)` = sprintf("%02d:%02d:%02d", as.integer(mean(time_hours)), as.integer((mean(time_hours) %% 1) * 60), round(((mean(time_hours) %% 1) * 60 %% 1) * 60)))

colnames(summary_table) <- c("Village", "Less than 2 hrs (%)", "Less than 6 hrs (%)", "Less than 10 hrs (%)", "More than 10 hrs (%)", "Mean time (hrs) (%)")

add_lot_link(caption = 'Time required to get to fishing grounds at village level (%)')

summary_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()
```


```{r}
# Summarize the data by village shared_facilities
summary_time_comparison <- tanganyika_survey %>%
  filter(!is.na(time_comparison) & time_comparison != "I DO NOT WANT TO ANSWER" & time_comparison != "I DON'T KNOW") %>% 
  group_by(time_comparison) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
time_comparison_table <- summary_time_comparison %>%
  select(time_comparison, proportion) %>%
  pivot_wider(names_from = time_comparison, values_from = proportion)

# Rename columns for clarity
colnames(time_comparison_table) <- c("Less", "More", "Not Sure", "Same")

# Format the proportion table values as percentages with one decimal point and add % sign
time_comparison_table <- time_comparison_table %>%
  mutate(across(c("Less", "More", "Not Sure", "Same"), ~ paste0(round(. * 100, 0))))

# Summarize the data by village shared_facilities
summary_catch_comparison <- tanganyika_survey %>%
  filter(!is.na(catch_comparison) & catch_comparison != "I DO NOT WANT TO ANSWER" & catch_comparison != "I DON'T KNOW") %>% 
  group_by(catch_comparison) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
catch_comparison_table <- summary_catch_comparison %>%
  select(catch_comparison, proportion) %>%
  pivot_wider(names_from = catch_comparison, values_from = proportion)

# Rename columns for clarity
colnames(catch_comparison_table) <- c("Less", "More", "Not Sure", "Same")

# Format the proportion table values as percentages with one decimal point and add % sign
catch_comparison_table <- catch_comparison_table %>%
  mutate(across(c("Less", "More", "Not Sure", "Same"), ~ paste0(round(. * 100, 0))))

# Reshape time_comparison_table to match the structure we need
time_comparison_table_long <- time_comparison_table %>%
  pivot_longer(cols = c("Less", "More", "Not Sure", "Same"), 
               names_to = "Response", 
               values_to = "Time_Comparison") 

# Reshape catch_comparison_table to match the structure we need
catch_comparison_table_long <- catch_comparison_table %>%
  pivot_longer(cols = c("Less", "More", "Not Sure", "Same"), 
               names_to = "Response", 
               values_to = "Catch_Comparison")

# Combine both tables by Response (which will align the rows based on "Less", "Same", and "More")
combined_table <- left_join(time_comparison_table_long, catch_comparison_table_long, by = "Response")

# Format the final table for better readability
# Rename columns and response labels
combined_table <- combined_table %>%
  mutate(
    Response = recode(Response, 
                      "Less" = "Decreased", 
                      "Same" = "No Change", 
                      "More" = "Increased", 
                      "Not Sure" = "Not Sure"),
    `Change in time needed to get to grounds compared to 5 years ago (%)` = Time_Comparison,
    `Change in average catch per trip compared to 5 years ago (%)` = Catch_Comparison
  ) %>% select(Response, 
         `Change in time needed to get to grounds compared to 5 years ago (%)`, 
         `Change in average catch per trip compared to 5 years ago (%)`)

add_lot_link(caption = 'Change in tiem required to access fishing ground and change in average catch compared to five years ago')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()

```

Respondents who stated they require less time to get to their fishing grounds revealed that they now have access to boats with engines (n = 35). They also highlighted the use of newer fishing tools and engines, which allow for quicker transportation to fishing areas. Interestingly, 50 household respondents mentioned that fish are now found closer to shore due to higher water levels, seasonal changes, and increased fish populations. Additionally, specific fish, such as dagaa, are more readily accessible near shallow waters, leading to shorter travel times for fishermen. Others (n = 10) mentioned that the reduction in time is simply because of the increased demands of other work, time constraints, and the need to balance fishing with business activities. However, they also highlighted that delayed departures make it harder to catch fish early, as fish are found farther away and are caught earlier in the day. 

Many fishers (n = 164) stated that it takes them roughly the same amount of time to reach their fishing ground. These fishers reported that the fishing activities still take place in the same areas, and the time taken to reach the grounds has not changed. Many highlighted that they continue to fish in the same spots, and the environmental conditions have not altered. However, a subset also expressed frustration as a lack of improvement in transportation and equipment, has resulted in no significant change in travel time to fishing areas as compared to five years ago. The challenges they face include using outdated boats and equipment, which are not suitable for long-distance travel, especially when weather conditions, such as wind, are unfavorable. 

Those fishers spending more time getting to their fishing grounds emphasized that, compared to 5 years ago, they need more time to reach the fishing grounds because fish have become scarce and are now found farther away (n = 82). The increasing number of fishers and illegal fishing practices have contributed to the depletion of nearby fish populations. As a result, fishers are traveling greater distances to find fish, which has led to longer travel times. Also, environmental changes, such as rising water levels, have pushed fish to deeper areas, further increasing the distance needed to access them. Five household respondents specifically mentioned that due to the establishment of fishing boundaries, including protected breeding areas and buoy barriers, they are now required to fish farther from the shore compared to five years ago.


```{r, fig.cap='Sale prices (TSh) of fish species over the past five years', fig.align='center', out.width = '90%'}
# Define target type variables for best values
target_type_best_vars <- c("dagaa_best", "migebuka_best", "kungura_best", 
                           "ngege_best", "kuhe_best", "sangara_best")

# Pivot longer and clean Fish_Species names for Best values
target_type_best_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_best_vars), 
               names_to = "Fish_Species", 
               values_to = "Best_Value") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_best", "") %>% str_to_title())

# Replace 97 with NA to treat as missing for Best values
target_type_best_long <- target_type_best_long %>%
  mutate(Best_Value = ifelse(Best_Value == 97, NA, Best_Value))

# Split data based on clusters for Best values
target_type_best_long_cluster_1 <- target_type_best_long %>%
  filter(village %in% cluster_1_villages)

target_type_best_long_cluster_2 <- target_type_best_long %>%
  filter(village %in% cluster_2_villages)

# Create survey design for Best values (Cluster 1)
strat_design_best_cluster_1 <- target_type_best_long_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Create survey design for Best values (Cluster 2)
strat_design_best_cluster_2 <- target_type_best_long_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize Best values for Cluster 1
aggregate_target_best_cluster_1 <- strat_design_best_cluster_1 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_best_value = survey_mean(Best_Value, vartype = "ci", na.rm = TRUE),
    mean_best_value_low = attr(mean_best_value, "ci")[1],
    mean_best_value_upp = attr(mean_best_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Summarize Best values for Cluster 2
aggregate_target_best_cluster_2 <- strat_design_best_cluster_2 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_best_value = survey_mean(Best_Value, vartype = "ci", na.rm = TRUE),
    mean_best_value_low = attr(mean_best_value, "ci")[1],
    mean_best_value_upp = attr(mean_best_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Combine Best values for both clusters
aggregate_target_best_combined <- bind_rows(
  aggregate_target_best_cluster_1 %>% mutate(cluster = "Cluster 1"),
  aggregate_target_best_cluster_2 %>% mutate(cluster = "Cluster 2")
)

# Define target type variables for worst values
target_type_worst_vars <- c("dagaa_worst", "migebuka_worst", "kungura_worst", 
                            "ngege_worst", "kuhe_worst", "sangara_worst")

# Pivot longer and clean Fish_Species names for Worst values
target_type_worst_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_worst_vars), 
               names_to = "Fish_Species", 
               values_to = "Worst_Value") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_worst", "") %>% str_to_title())

# Replace 97 with NA to treat as missing for Worst values
target_type_worst_long <- target_type_worst_long %>%
  mutate(Worst_Value = ifelse(Worst_Value == 97, NA, Worst_Value))

# Split data based on clusters for Worst values
target_type_worst_long_cluster_1 <- target_type_worst_long %>%
  filter(village %in% cluster_1_villages)

target_type_worst_long_cluster_2 <- target_type_worst_long %>%
  filter(village %in% cluster_2_villages)

# Create survey design for Worst values (Cluster 1)
strat_design_worst_cluster_1 <- target_type_worst_long_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Create survey design for Worst values (Cluster 2)
strat_design_worst_cluster_2 <- target_type_worst_long_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize Worst values for Cluster 1
aggregate_target_worst_cluster_1 <- strat_design_worst_cluster_1 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_worst_value = survey_mean(Worst_Value, vartype = "ci", na.rm = TRUE),
    mean_worst_value_low = attr(mean_worst_value, "ci")[1],
    mean_worst_value_upp = attr(mean_worst_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Summarize Worst values for Cluster 2
aggregate_target_worst_cluster_2 <- strat_design_worst_cluster_2 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_worst_value = survey_mean(Worst_Value, vartype = "ci", na.rm = TRUE),
    mean_worst_value_low = attr(mean_worst_value, "ci")[1],
    mean_worst_value_upp = attr(mean_worst_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Combine Worst values for both clusters
aggregate_target_worst_combined <- bind_rows(
  aggregate_target_worst_cluster_1 %>% mutate(cluster = "Cluster 1"),
  aggregate_target_worst_cluster_2 %>% mutate(cluster = "Cluster 2")
)

# Combine Best and Worst values into one dataframe
combined_target <- bind_rows(
  aggregate_target_best_combined %>%
    mutate(Value_Type = "Highest Sale Price", Value = mean_best_value) %>%
    select(-mean_best_value),  # remove `mean_best_value` after mutating
  aggregate_target_worst_combined %>%
    mutate(Value_Type = "Lowest Sale Price", Value = mean_worst_value) %>%
    select(-mean_worst_value))
  
combined_target$Fish_Species <- gsub("_process", "", combined_target$Fish_Species)

# Plotting the combined grouped bar chart with facets for each cluster and custom row titles
ggplot(combined_target, aes(x = Fish_Species, y = Value, fill = Value_Type)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.75) +
  geom_errorbar(aes(ymin = ifelse(Value_Type == "Highest Sale Price", 
                                  mean_best_value_low, mean_worst_value_low), 
                    ymax = ifelse(Value_Type == "Highest Sale Price", 
                                  mean_best_value_upp, mean_worst_value_upp)), 
                position = position_dodge(0.75), width = 0.2) +
  labs(x = NULL, y = "Sale Price (TSh)") +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "bottom", 
        axis.text.x = element_text(size = 10), 
        strip.text = element_text(size = 12, face = "bold"),  # Set custom size and bold text for facet labels
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),
        legend.box = "horizontal") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = scales::label_comma()) +
  facet_wrap(~ cluster, nrow = 2, labeller = labeller(cluster = c("Cluster 1" = "Overall North", "Cluster 2" = "Overall South")))


```

Most fish, as was indicated by 129 fishers, is sold locally to small-scale fish traders. A further 83 respondents indicated selling their fish to traders. These traders include various individuals and groups involved in the fish market, both locally and from outside the region. A notable portion of participants (n = 42) mentioned selling their fish directly to fish buyers, consumers, and end users. These buyers are often local residents, or individuals seeking fish for personal consumption. Other fish sales were made to local communities and markets, boat owners, large-scale fish traders, fish brokers and intermediaries, as well as fish traders from neighboring countries including Zambia, Congo, and Burundi.

Decreases in catch were attributed to an increase in illegal fishing practices (n = 121). The widespread use of illegal fishing gear, such as monofilament nets, has significantly depleted fish populations. These practices, which include night fishing and the use of harmful nets, not only catch large numbers of fish but also target juvenile fish, disrupting fish breeding areas. Others voiced their concern about increasing fishing pressure (n = 60), increases in the number of fishers, fishing gear, and fishing boats has led to a decrease in fish availability compared to five years ago. The growing demand for fish and the rise in fishing activities have intensified competition for resources, resulting in fewer fish in the waters. On the contrary, some respondents (n = 17) argued that decreases in fish catch are due to a lack of proper fishing equipment, the use of outdated or poor-quality tools, and the absence of modern fishing techniques and machinery such as boats and advanced nets. Some attributed decreases in catch to changing weather patterns, including increased wind, storms, and irregular rainfall. These weather changes have made fish more difficult to find, especially during dry seasons when they move farther away.

Few fishers indicated stability or an increase in fish catches compared to five years ago. Nine respondents shared that their catch has remained the same as their fishing methods have not changed, whereas five respondents reported that they catch more fish now due to having better and modern fishing equipment, including high-quality tools and nets. Other reasons for unchanged catch levels pertained to increased variability in fish movements, weather patterns, and water levels, but an overall consistency in conditions. Four respondents stated that an increase in the fish caught could be attributed to the decline of illegal fishing practices, which has been controlled and reduced. Positively, respondents also stated that the closure of fishing sites has facilitated fish breeding, leading to a higher number of fish available for capture (n = 30). Also, the enforcement of fishing regulations and the improved management of the lake were mentioned as important factors in the increase in fish caught. 


```{r, fig.cap='Satisfaction levels of fishers', fig.align='center', out.width = '90%'}
# Define the mapping for satisfaction levels
satisfaction_mapping <- c(
  "1 VERY UNSATISFIED" = 1,
  "2 UNSATISFIED" = 2,
  "3 NEUTRAL" = 3,
  "4 SATISFIED" = 4,
  "5 VERY SATISFIED" = 5
)

# Satisfaction columns
satisfaction_columns <- c("satisfaction_skills", "tools_used", "catch_gained", 
                          "market_supply", "satisfaction_purchase", "satisfaction_market", 
                          "satisfaction_income", "satisfaction_capital", "business_skills", 
                          "organization_support")

# Convert columns to numeric values
tanganyika_clean <- tanganyika_clean %>%
  mutate(across(all_of(satisfaction_columns), 
                ~ recode(., !!!satisfaction_mapping)))

# Pivot longer to reshape the data
satisfaction_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(satisfaction_columns), names_to = "Satisfaction_Area", values_to = "Satisfaction_Value")

# Filter out rows with NA values
satisfaction_long <- satisfaction_long %>%
  filter(!is.na(Satisfaction_Value))

# Add cluster classification
satisfaction_long <- satisfaction_long %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Overall North",
    village %in% cluster_2_villages ~ "Overall South",
    TRUE ~ "Other"
  ))

# Create survey design for Cluster 1
satisfaction_design_cluster_1 <- satisfaction_long %>%
  filter(cluster == "Overall North") %>%
  group_by(stype) %>%
  mutate(fpc = ifelse(n() > first(fpc), n(), first(fpc))) %>%
  ungroup() %>%
  as_survey_design(strata = stype, fpc = fpc)

# Create survey design for Cluster 2
satisfaction_design_cluster_2 <- satisfaction_long %>%
  filter(cluster == "Overall South") %>%
  group_by(stype) %>%
  mutate(fpc = ifelse(n() > first(fpc), n(), first(fpc))) %>%
  ungroup() %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize for Cluster 1
aggregate_satisfaction_cluster_1 <- satisfaction_design_cluster_1 %>%
  group_by(Satisfaction_Area) %>%
  summarise(
    mean_satisfaction_value = survey_mean(Satisfaction_Value, vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(cluster = "Overall North")

# Summarize for Cluster 2
aggregate_satisfaction_cluster_2 <- satisfaction_design_cluster_2 %>%
  group_by(Satisfaction_Area) %>%
  summarise(
    mean_satisfaction_value = survey_mean(Satisfaction_Value, vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(cluster = "Overall South")

# Combine the results from both clusters
aggregate_satisfaction_combined <- bind_rows(aggregate_satisfaction_cluster_1, aggregate_satisfaction_cluster_2)

# Plotting Satisfaction Values with clusters separated
ggplot(aggregate_satisfaction_combined, aes(
  x = reorder(Satisfaction_Area, -mean_satisfaction_value), 
  y = mean_satisfaction_value, 
  fill = Satisfaction_Area
)) +
  geom_bar(stat = "identity", width = 0.75) +
  labs(x = NULL, y = NULL) +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(
    legend.position = "none", 
    axis.text.x = element_text(angle = 45, hjust = 1), 
    strip.text = element_text(size = 12, face = "bold"), # Add bold, larger cluster titles
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),
    legend.box = "horizontal"
  ) +
  scale_y_continuous(
    limits = c(0, 5), 
    breaks = 1:5, 
    labels = c("VERY UNSATISFIED", "UNSATISFIED", "NEUTRAL", "SATISFIED", "VERY SATISFIED")
  ) +
  scale_x_discrete(labels = c(
    "Your fishing skills", 
    "Your own business skills", 
    "Your access to markets\nofftake/sales", 
    "Your catch\nlevels gained", 
    "Your income\nlevels generated", 
    "The tools and\ntechnologies you use", 
    "Your access to\nmarket supply (inputs)", 
    "Your access to capital", 
    "Your access to purchasing\nequipment for fishing", 
    "The support you get from\ngroups or organizations"
  )) +
  facet_wrap(~ cluster, nrow = 2, scales = "free_y", strip.position = "top")


```

Fishers expressed a variety of challenges that they face on and off the water. Most significantly, unfavorable weather conditions, such as strong winds, storms, and heavy rains, pose significant risks, including accidents and disruptions to fishing activities (n =  232). Inadequate fishing gear and outdated technology (i.e. old boats, engines, and low-quality tools) limit fisher’s efficiency and safety (n = 106), while financial constraints prevent investments in modern equipment (n = 29). Declining fish stock availability and illegal fishing practices exacerbate these difficulties. Piracy was listed as a major concern (n = 74), common issues include theft and destruction of fishing gear, hijacking boats, and violent attacks during fishing activities. Many fishers reported being attacked by pirates at night, losing valuable equipment like engines and nets, and being left without resources. Additional issues include unreliable markets and fluctuating prices. Regulatory challenges, such as high fees and equipment confiscation, were stated to further complicate their work. Furthermore, rising costs, a lack of education, human-wildlife conflict (i.e. hippos, crocodiles), and restrictions imposed on fishing areas due to the implementation conservation zones also pose other challenges.

A significant number of fishers highlighted several changes that could improve fishing practices, including access to modern and reliable equipment such as improved boats, modern nets, and even safety tools like buoys and fire extinguishers (n = 181). Improved safety and protective measures were also emphasized to address theft, piracy, and weather-related risks (n = 57). Suggestions focused on both immediate security needs and proactive safety strategies. Access to financial support like loans and microfinance to invest in better gear and increase productivity were also highly sought after (n = 96). Support for education and skill development related to trainings on sustainable fishing methods were also considered vital (n = 61), along with improved governance, stricter enforcement of fishing regulations, and better market access to stabilize fish prices and boost profitability. Strengthened collaboration among fishers and relevant stakeholders was suggested to improve fair representation in decision-making processes and to address challenges. Fishermen consistently emphasized the urgent need to address illegal fishing to sustain fish populations and improve legal fishers' livelihoods (n = 41). Suggestions highlighted stricter enforcement of fishing regulations, eradication of illegal gear, and empowering local authorities to monitor and control illegal practices. Fishers also highlighted the need to protect fish breeding areas, address the impact of changing weather conditions, and promote the use of sustainable fishing tools. They emphasized that improving the ecosystem is essential for ensuring a steady supply of fish and increasing their income.

```{r, fig.cap='Do you think BMUs are helpful to improving your fishing practices?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
village_data_expanded <- tanganyika_survey %>%
  filter(!is.na(sustainability_population) & sustainability_population != "I DON'T KNOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
village_data_design_cluster_1 <- village_data_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

village_data_design_cluster_2 <- village_data_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
village_data_cluster_1 <- village_data_design_cluster_1 %>%
  group_by(sustainability_population) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
village_data_cluster_2 <- village_data_design_cluster_2 %>%
  group_by(sustainability_population) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(village_data_combined, aes(x = fct_relevel(sustainability_population, "YES", "NO", "NOT SURE"), 
                                  y = proportion * 100, fill = sustainability_population)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), 
        axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

```{r, fig.cap='Do you think BMUs are helpful to improving your fishing practices?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
village_data_expanded <- tanganyika_survey %>%
  filter(!is.na(bmu_helpfulness)) %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
village_data_design_cluster_1 <- village_data_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

village_data_design_cluster_2 <- village_data_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
village_data_cluster_1 <- village_data_design_cluster_1 %>%
  group_by(bmu_helpfulness) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
village_data_cluster_2 <- village_data_design_cluster_2 %>%
  group_by(bmu_helpfulness) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(village_data_combined, aes(x = fct_relevel(bmu_helpfulness, "YES", "NO", "NOT SURE"), 
                                  y = proportion * 100, fill = bmu_helpfulness)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), 
        axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(cooperative) & cooperative != "I DON'T KNOW") %>% 
  group_by(village, cooperative) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
cooperative_table <- summary_by_village %>%
  select(village, cooperative, proportion) %>%
  pivot_wider(names_from = cooperative, values_from = proportion)

# Rename columns for clarity
colnames(cooperative_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
cooperative_table <- cooperative_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(cocoba_group) & cocoba_group != "I DON'T KNOW") %>% 
  group_by(village, cocoba_group) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
cocoba_group_table <- summary_by_village %>%
  select(village, cocoba_group, proportion) %>%
  pivot_wider(names_from = cocoba_group, values_from = proportion)

# Rename columns for clarity
colnames(cocoba_group_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
cocoba_group_table <- cocoba_group_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))


summary_by_village <- tanganyika_survey %>%
  filter(!is.na(other_group) & other_group != "I DON'T KNOW") %>% 
  group_by(village, other_group) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
other_group_table <- summary_by_village %>%
  select(village, other_group, proportion) %>%
  pivot_wider(names_from = other_group, values_from = proportion)

# Rename columns for clarity
colnames(other_group_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
other_group_table <- other_group_table %>%
  mutate(across(c("No", "Yes"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(tnc_support) & tnc_support != "I DON'T KNOW") %>% 
  group_by(village, tnc_support) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
tnc_support_table <- summary_by_village %>%
  select(village, tnc_support, proportion) %>%
  pivot_wider(names_from = tnc_support, values_from = proportion)

# Rename columns for clarity
colnames(tnc_support_table) <- c("Village", "Yes", "No", "Not Sure")

# Format the proportion table values as percentages with one decimal point and add % sign
tnc_support_table <- tnc_support_table %>%
  mutate(across(c("Yes", "No", "Not Sure"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(group_helpfulness) & group_helpfulness != "I DON'T KNOW") %>% 
  group_by(village, group_helpfulness) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
group_helpfulness_table <- summary_by_village %>%
  select(village, group_helpfulness, proportion) %>%
  pivot_wider(names_from = group_helpfulness, values_from = proportion)

# Rename columns for clarity
colnames(group_helpfulness_table) <- c("Village", "Yes", "No", "Not Sure")

# Format the proportion table values as percentages with one decimal point and add % sign
group_helpfulness_table <- group_helpfulness_table %>%
  mutate(across(c("Yes", "No", "Not Sure"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

combined_table <- cooperative_table %>%
  select(Village, `Cooperative/FICO` = Yes) %>%  
  left_join(cocoba_group_table %>% select(Village, `COCOBA or savings group` = Yes), by = "Village") %>%
  left_join(other_group_table %>% select(Village, `Other group` = Yes), by = "Village") %>%
  left_join(tnc_support_table %>% select(Village, `Group is TNC supported` = Yes), by = "Village") %>%
  left_join(group_helpfulness_table %>% select(Village, `Group is helpful` = Yes), by = "Village") 

# Calculate the overall average for all villages combined
total_row <- combined_table %>%
  summarise(
    Village = "Overall",
    `Cooperative/FICO` = mean(as.numeric(sub("%", "", `Cooperative/FICO`)) / 100, na.rm = TRUE) * 100,
    `COCOBA or savings group` = mean(as.numeric(sub("%", "", `COCOBA or savings group`)) / 100, na.rm = TRUE) * 100,
    `Other group` = mean(as.numeric(sub("%", "", `Other group`)) / 100, na.rm = TRUE) * 100,
    `Group is TNC supported` = mean(as.numeric(sub("%", "", `Group is TNC supported`)) / 100, na.rm = TRUE) * 100,
    `Group is helpful` = mean(as.numeric(sub("%", "", `Group is helpful`)) / 100, na.rm = TRUE) * 100) %>%
  mutate(
    `Cooperative/FICO` = paste0(round(`Cooperative/FICO`, 0)),
    `COCOBA or savings group` = paste0(round(`COCOBA or savings group`, 0)),
    `Other group` = paste0(round(`Other group`, 0)),
    `Group is TNC supported` = paste0(round(`Group is TNC supported`, 0)),
    `Group is helpful` = paste0(round(`Group is helpful`, 0)))

total_row <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Cooperative/FICO` = survey_mean(cooperative == "YES", na.rm = TRUE) * 100,
    `COCOBA or savings group` = survey_mean(cocoba_group == "YES", na.rm = TRUE) * 100,
    `Other group` = survey_mean(other_group == "YES", na.rm = TRUE) * 100,
    `Group is TNC supported` = survey_mean(tnc_support == "YES", na.rm = TRUE) * 100,
    `Group is helpful` = survey_mean(group_helpfulness == "YES", na.rm = TRUE) * 100) %>%
  mutate(
    `Cooperative/FICO` = paste0(round(`Cooperative/FICO`, 0)),
    `COCOBA or savings group` = paste0(round(`COCOBA or savings group`, 0)),
    `Other group` = paste0(round(`Other group`, 0)),
    `Group is TNC supported` = paste0(round(`Group is TNC supported`, 0)),
    `Group is helpful` = paste0(round(`Group is helpful`, 0))) %>% select(-contains("_se"))

# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)
colnames(combined_table) <- c("Village", "Cooperative/FICO (%)", "COCOBA or savings group (%)", "Other group (%)", "TNC supported groups (%)", "Group is helpful (%)")

add_lot_link(caption = 'Group membership of fishers at village level (%)')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()

```

Fishing group members indicated the need for increased financial support and resources, such as providing capital or loans, and creating group laws to facilitate access to loans (n = 10). They also mentioned for the members themselves they need to be more accountable in paying their membership shares on time, encouraging timely repayment. Furthermore, respondents shared the need for increased education and training, including education on illegal fishing, entrepreneurship, and loans. They emphasized the importance of seminars and meetings for better management of activities. Furthermore, group members reiterated the need to increase access to improved fishing equipment, group and governance structures.

```{r, fig.cap='Do you think your current activities are likely to support your needs over the long term (next 5 - 10 years)?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
village_data_expanded <- tanganyika_survey %>%
  filter(!is.na(activity_long_term)) %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
village_data_design_cluster_1 <- village_data_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

village_data_design_cluster_2 <- village_data_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
village_data_cluster_1 <- village_data_design_cluster_1 %>%
  group_by(activity_long_term) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
village_data_cluster_2 <- village_data_design_cluster_2 %>%
  group_by(activity_long_term) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(village_data_combined, aes(x = fct_relevel(activity_long_term, "YES", "NO", "NOT SURE"), 
                                  y = proportion * 100, fill = activity_long_term)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), 
        axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

Households expressed confidence in their current activities, citing financial stability and the ability to meet their needs as well as being able to save for the future (n = 9). Respondents highlighted that their income from activities like fishing and business is sufficient to support their families. They feel secure about their ability to sustain their livelihoods over the next 5-10 years and are satisfied with the level of income they currently earn. One respondent noted that conservation and sustainable fishing practices in their area provide long-term assurance of fish availability. They expressed confidence that such measures would ensure their activities remain viable over the next 5-10 years. Another respondent was optimistic about future improvements in their livelihood, believing that fish populations and agricultural productivity will increase.

Many households (n = 32) expressed that their current income levels are insufficient to meet their basic needs, both in the short and long term. The income they earn is too low to provide long-term financial security, and with current activities offering little opportunity for growth, they are uncertain about sustaining their needs over the next 5-10 years. Respondents felt that their low income, especially from seasonal or unstable sources, makes long-term financial stability unlikely. Four households mentioned that a lack of proper tools and fishing equipment severely limits their ability to generate enough income over the long term. Without adequate equipment, their fishing activities cannot meet their needs consistently, and the time and cost involved in replacing broken tools will make it difficult to sustain their livelihood in the coming years. Others (n = 2) worried about the declining availability of fish due to an increasing number of fishermen and the use of improved fishing equipment. They noted that as more fishermen enter the industry with improved tools, the pressure on fish stocks intensifies, leading to a decrease in the number of fish available for catch. This, combined with occasional poor catches, threatens their ability to rely on fishing as a long-term livelihood. Furthermore, respondents indicated reasons pertaining to pressures exerted by illegal fishing practices, broader economic challenges including high living costs and limited opportunities for alternative income, their age and health affecting their ability to support their livelihood, as well as the pressures and uncertainties surrounding fishing- and farming-based practices, which threaten the long-term sustainability of their livelihoods.

Unsustainable practices

Ecologically unsustainable fishing practices persist due to the widespread use of illegal nets (i.e. monofilament, kokoro), which damage aquatic ecosystems and deplete fish stocks (n = 51). Pollution from oil spills, improper waste disposal, and the mishandling of fish are also believed to cause harm to the environment, disrupting aquatic ecosystems and compromising vital habitats for fish reproduction (n = 3). Limited capital prevents fishers from acquiring proper tools and equipment needed for sustainable fishing and conservation efforts (n = 4), while security challenges like theft of boats and gear discourage investment in better practices (n = 9). Additionally, one respondent highlighted that gaps in knowledge about sustainable fishing techniques lead to harmful methods that exacerbate resource depletion and threaten the long-term stability of fishing communities.

Respondents from some households (n = 4) stated that there are no unsustainable practices in their fishing activities. These responses might suggest an unfamiliarity with the concept of sustainability or that respondents do not recognize the potentially negative impacts of their fishing methods. This highlights the need for greater education and awareness about sustainable fishing practices and the long-term effects of certain fishing methods on the environment and community livelihoods.




</div>
\newpage

<!-- rust page -->
<div class ="section-rust">

## Livelihood Practices of Fish Traders

```{r, fig.cap='Forms of fish trading', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
village_data_expanded <- tanganyika_survey %>%
  filter(!is.na(trading_form)) %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
village_data_design_cluster_1 <- village_data_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

village_data_design_cluster_2 <- village_data_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
village_data_cluster_1 <- village_data_design_cluster_1 %>%
  group_by(trading_form) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
village_data_cluster_2 <- village_data_design_cluster_2 %>%
  group_by(trading_form) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(village_data_combined, aes(x = fct_relevel(trading_form, "TRADER", "PREPARES FISH"), 
                                  y = proportion * 100, fill = trading_form)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, ymin = pmax(proportion_low, 0) * 100), width = 0.2) +
  geom_text(
    aes(y = pmin(proportion_upp, 1) * 100 + 1, label = paste0(round(proportion * 100, 0), "%")), 
    position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.text.y = element_blank(), 
        axis.title.y = element_blank()) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Trader", "Prepares Fish")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster

```

The majority of fish traders (n = 92) mentioned buying fish directly from fishers at the shore, then selling them fresh or after processing at local markets. Few traders stated that they purchase fish from different villages and coastal areas (n = 25), directly from processing facilities (n = 2), or from local middlemen (n = 2). The primary customer base of fish traders were wholesale buyers (n = 67). Respondents shared that they sell primarily to small and large-scale traders within the region, neighboring areas, and internationally, including markets in Zambia, Burundi, and Congo. Key markets include Namanyere, Sumbawanga, and Songwe, with customers ranging from local vendors to wholesalers and exporters.

```{r, fig.cap='Seasonal trading of fish species over the past five years', fig.align='center', out.width = '90%'}
# Define target type variables
target_type_vars <- c("dagaa_trade_season", "migebuka_trade_season", "kungura_trade_season", 
                      "ngege_trade_season", "kuhe_trade_season", "sangara_trade_season")

# Pivot longer and clean Fish_Species names
target_type_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_vars), 
               names_to = "Fish_Species", 
               values_to = "Season") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_trade_season", "") %>% str_to_title())

# Consolidate and clean `Season` values
target_type_long <- target_type_long %>%
  mutate(
    Season = case_when(
      str_detect(Season, "ALL SEASONS") & str_detect(Season, "RAINY SEASON") ~ "ALL SEASONS",
      str_detect(Season, "ALL SEASONS") & str_detect(Season, "DRY SEASON") ~ "ALL SEASONS",
      str_detect(Season, "RAINY SEASON") & str_detect(Season, "DRY SEASON") ~ "ALL SEASONS",
      Season == "I DON'T KNOW" ~ NA_character_,  
      TRUE ~ Season))

# Add cluster classification
target_type_long <- target_type_long %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"
  ))

# Create survey design
strat_design <- target_type_long %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize by Fish_Species and Season for each cluster
aggregate_target_type <- strat_design %>%
  group_by(Fish_Species, Season, cluster) %>%
  summarise(mean_season = survey_mean(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>% ungroup()

# Calculate percentages and handle totals
aggregate_target_type <- aggregate_target_type %>%
  filter(!is.na(Season) & Season != "NONE") %>% 
  group_by(Fish_Species, cluster) %>%
  mutate(
    total_season = sum(mean_season, na.rm = TRUE), # Total importance per Fish_Species
    mean_season_percent = (mean_season / total_season) * 100, # Relative percentage
    mean_season_percent_low = (mean_season_low / total_season) * 100,  # Lower bound of percentage
    mean_season_percent_upp = (mean_season_upp / total_season) * 100   # Upper bound of percentage
  ) %>%
  ungroup()

# Plotting with facet_wrap to separate by Cluster
ggplot(aggregate_target_type, aes(x = Fish_Species, y = mean_season_percent, group = Season, fill = Season)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymin = mean_season_percent_low, ymax = mean_season_percent_upp),
                position = position_dodge(width = 0.95), width = 0.2) +
  geom_text(aes(y = pmin(mean_season_percent_upp, 100) + 3, 
                label = scales::percent(mean_season_percent/100, accuracy = 1)),
            position = position_dodge(width = 0.95), size = 3) +
  labs(x = NULL, y = NULL) +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D", labels = function(labels) str_to_title(str_to_lower(labels))) +
  sea::theme_sea() + 
  theme(legend.position = "bottom", 
        legend.direction = "horizontal", 
        legend.justification = "center", 
        axis.text.x = element_text(size = 10),
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        strip.text = element_text(size = 12, face = "bold"),  # Customizing strip text size and style
        legend.box = "horizontal") + 
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  facet_wrap(~ cluster, nrow = 2, labeller = labeller(cluster = c("Cluster 1" = "Overall North", "Cluster 2" = "Overall South")))  # Custom labels for cluster
```


```{r, fig.cap='Fish trading sale prices (TSh) of fish species over the past five years', fig.align='center', out.width = '90%'}
# Define target type variables for best values
target_type_best_vars <- c("dagaa_trade_best", "migebuka_trade_best", "kungura_trade_best", 
                           "ngege_trade_best", "kuhe_trade_best", "sangara_trade_best")

# Pivot longer and clean Fish_Species names for Best values
target_type_best_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_best_vars), 
               names_to = "Fish_Species", 
               values_to = "Best_Value") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_best", "") %>% str_to_title())

# Replace 97 with NA to treat as missing for Best values
target_type_best_long <- target_type_best_long %>%
  mutate(Best_Value = ifelse(Best_Value == 97, NA, Best_Value))

# Split data based on clusters for Best values
target_type_best_long_cluster_1 <- target_type_best_long %>%
  filter(village %in% cluster_1_villages)

target_type_best_long_cluster_2 <- target_type_best_long %>%
  filter(village %in% cluster_2_villages)

# Create survey design for Best values (Cluster 1)
strat_design_best_cluster_1 <- target_type_best_long_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Create survey design for Best values (Cluster 2)
strat_design_best_cluster_2 <- target_type_best_long_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize Best values for Cluster 1
aggregate_target_best_cluster_1 <- strat_design_best_cluster_1 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_best_value = survey_mean(Best_Value, vartype = "ci", na.rm = TRUE),
    mean_best_value_low = attr(mean_best_value, "ci")[1],
    mean_best_value_upp = attr(mean_best_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Summarize Best values for Cluster 2
aggregate_target_best_cluster_2 <- strat_design_best_cluster_2 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_best_value = survey_mean(Best_Value, vartype = "ci", na.rm = TRUE),
    mean_best_value_low = attr(mean_best_value, "ci")[1],
    mean_best_value_upp = attr(mean_best_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Combine Best values for both clusters
aggregate_target_best_combined <- bind_rows(
  aggregate_target_best_cluster_1 %>% mutate(cluster = "Cluster 1"),
  aggregate_target_best_cluster_2 %>% mutate(cluster = "Cluster 2")
)

# Define target type variables for worst values
target_type_worst_vars <- c("dagaa_trade_worst", "migebuka_trade_worst", "kungura_trade_worst", 
                            "ngege_trade_worst", "kuhe_trade_worst", "sangara_trade_worst")

# Pivot longer and clean Fish_Species names for Worst values
target_type_worst_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_worst_vars), 
               names_to = "Fish_Species", 
               values_to = "Worst_Value") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_worst", "") %>% str_to_title())

# Replace 97 with NA to treat as missing for Worst values
target_type_worst_long <- target_type_worst_long %>%
  mutate(Worst_Value = ifelse(Worst_Value == 97, NA, Worst_Value))

# Split data based on clusters for Worst values
target_type_worst_long_cluster_1 <- target_type_worst_long %>%
  filter(village %in% cluster_1_villages)

target_type_worst_long_cluster_2 <- target_type_worst_long %>%
  filter(village %in% cluster_2_villages)

# Create survey design for Worst values (Cluster 1)
strat_design_worst_cluster_1 <- target_type_worst_long_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Create survey design for Worst values (Cluster 2)
strat_design_worst_cluster_2 <- target_type_worst_long_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize Worst values for Cluster 1
aggregate_target_worst_cluster_1 <- strat_design_worst_cluster_1 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_worst_value = survey_mean(Worst_Value, vartype = "ci", na.rm = TRUE),
    mean_worst_value_low = attr(mean_worst_value, "ci")[1],
    mean_worst_value_upp = attr(mean_worst_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Summarize Worst values for Cluster 2
aggregate_target_worst_cluster_2 <- strat_design_worst_cluster_2 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_worst_value = survey_mean(Worst_Value, vartype = "ci", na.rm = TRUE),
    mean_worst_value_low = attr(mean_worst_value, "ci")[1],
    mean_worst_value_upp = attr(mean_worst_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Combine Worst values for both clusters
aggregate_target_worst_combined <- bind_rows(
  aggregate_target_worst_cluster_1 %>% mutate(cluster = "Cluster 1"),
  aggregate_target_worst_cluster_2 %>% mutate(cluster = "Cluster 2")
)

# Combine Best and Worst values into one dataframe
combined_target <- bind_rows(
  aggregate_target_best_combined %>%
    mutate(Value_Type = "Highest Sale Price", Value = mean_best_value) %>%
    select(-mean_best_value),  # remove `mean_best_value` after mutating
  aggregate_target_worst_combined %>%
    mutate(Value_Type = "Lowest Sale Price", Value = mean_worst_value) %>%
    select(-mean_worst_value))
  
combined_target$Fish_Species <- gsub("_process", "", combined_target$Fish_Species)

# Plotting the combined grouped bar chart with facets for each cluster and custom row titles
ggplot(combined_target, aes(x = Fish_Species, y = Value, fill = Value_Type)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.75) +
  geom_errorbar(aes(ymin = ifelse(Value_Type == "Highest Sale Price", 
                                  mean_best_value_low, mean_worst_value_low), 
                    ymax = ifelse(Value_Type == "Highest Sale Price", 
                                  mean_best_value_upp, mean_worst_value_upp)), 
                position = position_dodge(0.75), width = 0.2) +
  labs(x = NULL, y = "Sale Price (TSh)") +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "bottom", 
        axis.text.x = element_text(size = 10), 
        strip.text = element_text(size = 12, face = "bold"),  # Set custom size and bold text for facet labels
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),
        legend.box = "horizontal") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = scales::label_comma()) +
  facet_wrap(~ cluster, nrow = 2, labeller = labeller(cluster = c("Cluster 1" = "Overall North", "Cluster 2" = "Overall South")))



```

```{r, fig.cap='Satisfaction of fish traders', fig.align='center', out.width = '90%'}
# Define the mapping for satisfaction levels
satisfaction_mapping <- c(
  "1 VERY UNSATISFIED" = 1,
  "2 UNSATISFIED" = 2,
  "3 NEUTRAL" = 3,
  "4 SATISFIED" = 4,
  "5 VERY SATISFIED" = 5
)

satisfaction_columns <- c("satisfaction_trade_skills", "trade_tools_used", "trade_productivity", 
                          "trade_market_supply", "satisfaction_trade_purchase", "trade_market", 
                          "trade_income", "trade_capital", "trade_business_skills", 
                          "trade_organization_support")

# Convert columns to numeric values
tanganyika_clean <- tanganyika_clean %>%
  mutate(across(all_of(satisfaction_columns), 
                ~ recode(., !!!satisfaction_mapping)))

# Pivot longer to reshape the data
satisfaction_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(satisfaction_columns), names_to = "Satisfaction_Area", values_to = "Satisfaction_Value")

# Filter out rows with NA values
satisfaction_long <- satisfaction_long %>%
  filter(!is.na(Satisfaction_Value))

# Add cluster classification
satisfaction_long <- satisfaction_long %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Overall North",  # Cluster 1
    village %in% cluster_2_villages ~ "Overall South",  # Cluster 2
    TRUE ~ "Other"
  ))

# Create survey design
strat_design_satisfaction <- satisfaction_long %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize satisfaction values by cluster
aggregate_satisfaction <- strat_design_satisfaction %>%
  group_by(Satisfaction_Area, cluster) %>%
  summarise(
    mean_satisfaction_value = survey_mean(Satisfaction_Value, vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  ungroup()

# Plotting Satisfaction Values with clusters separated into rows
ggplot(aggregate_satisfaction, aes(
  x = reorder(Satisfaction_Area, -mean_satisfaction_value), 
  y = mean_satisfaction_value, 
  fill = Satisfaction_Area
)) +
  geom_bar(stat = "identity", width = 0.75) +
  labs(x = NULL, y = NULL) +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(
    legend.position = "none", 
    axis.text.x = element_text(angle = 45, hjust = 1), 
    strip.text = element_text(size = 12, face = "bold"), # Add bold, larger cluster titles
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),
    legend.box = "horizontal"
  ) +
  scale_y_continuous(
    limits = c(0, 5), 
    breaks = 1:5, 
    labels = c("VERY UNSATISFIED", "UNSATISFIED", "NEUTRAL", "SATISFIED", "VERY SATISFIED")
  ) +
  scale_x_discrete(labels = c(
    "Your skills", 
    "Your own business skills", 
    "The tools and\ntechnologies you use", 
    "Your productivity levels", 
    "Your access to\nmarket supply (inputs)", 
    "Your access to markets\nofftake/sales", 
    "Your income\nlevels generated", 
    "Your access to materials and\nequipment needed for trading", 
    "Your access to capital", 
    "The support you get from\ngroups or organizations"
  )) +
  facet_wrap(~ cluster, nrow = 2, scales = "free_y", strip.position = "top")

```

Fish traders indicated a variety of challenges that compromise their operations and profitability. Fluctuating fish prices and market instability often lead to financial losses (n = 43), while limited capital restricts the ability to expand or invest in essential tools (n = 48). Inadequate storage and poor transportation infrastructure contribute to fish spoilage, reducing quality and market value (n = 24). Accessing reliable markets and customers is stated to be difficult and compounded by long travel distances and oversaturation of markets (n = 24). Traders also encounter regulatory hurdles, such as high taxes and permit costs, and financial constraints, including delayed payments and limited access to loans. Poor infrastructure, competition, insufficient equipment, and lack of education in business management further exacerbate these issues. Additionally, seasonal and environmental factors, such as reduced fish availability during rainy seasons, pose significant challenges to sustaining livelihoods.

Changes to improve fish trading
To improve fish trader livelihoods, respondents emphasized the need for more accessible and reliable markets, both locally and internationally, with government support to establish and expand connections to external markets for better sales opportunities (n = 33). Respondents advocated for fair and standardized pricing to ensure market stability and profitability (n = 11). Furthermore, access to affordable capital and financial support, such as low-interest loans, is regarded as essential for expanding operations (n = 65). Traders also requested improved tools, storage facilities, and modern preservation technologies to maintain fish quality (n = 16). Better infrastructure, including reliable transportation and electricity, is deemed necessary to enhance fish preservation (n = 12). Education and training in business management and fish preparation were highlighted as critical for improving skills (n = 8). Additionally, respondents called for regulatory reforms for fish trading and improve tax policies  (n = 9), along with establishing fish processing plants to add value and ensure steady market access (n = 2). 


```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(cooperative_fico) & cooperative_fico != "I DON'T KNOW") %>% 
  group_by(village, cooperative_fico) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
cooperative_table <- summary_by_village %>%
  select(village, cooperative_fico, proportion) %>%
  pivot_wider(names_from = cooperative_fico, values_from = proportion)

# Rename columns for clarity
colnames(cooperative_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
cooperative_table <- cooperative_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(cocoba_savings) & cocoba_savings != "I DON'T KNOW") %>% 
  group_by(village, cocoba_savings) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
cocoba_group_table <- summary_by_village %>%
  select(village, cocoba_savings, proportion) %>%
  pivot_wider(names_from = cocoba_savings, values_from = proportion)

# Rename columns for clarity
colnames(cocoba_group_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
cocoba_group_table <- cocoba_group_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(other_trading_group) & other_trading_group != "I DON'T KNOW") %>% 
  group_by(village, other_trading_group) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
other_group_table <- summary_by_village %>%
  select(village, other_trading_group, proportion) %>%
  pivot_wider(names_from = other_trading_group, values_from = proportion)

# Rename columns for clarity
colnames(other_group_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
other_group_table <- other_group_table %>%
  mutate(across(c("No", "Yes"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(trading_tnc_supported) & trading_tnc_supported != "I DON'T KNOW") %>% 
  group_by(village, trading_tnc_supported) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
tnc_support_table <- summary_by_village %>%
  select(village, trading_tnc_supported, proportion) %>%
  pivot_wider(names_from = trading_tnc_supported, values_from = proportion)

# Rename columns for clarity
colnames(tnc_support_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
tnc_support_table <- tnc_support_table %>%
  mutate(across(c("Yes", "No"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(trading_group_helpfulness) & trading_group_helpfulness != "I DON'T KNOW") %>% 
  group_by(village, trading_group_helpfulness) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
group_helpfulness_table <- summary_by_village %>%
  select(village, trading_group_helpfulness, proportion) %>%
  pivot_wider(names_from = trading_group_helpfulness, values_from = proportion)

# Rename columns for clarity
colnames(group_helpfulness_table) <- c("Village", "Yes", "No", "Not Sure")

# Format the proportion table values as percentages with one decimal point and add % sign
group_helpfulness_table <- group_helpfulness_table %>%
  mutate(across(c("Yes", "No", "Not Sure"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

combined_table <- cooperative_table %>%
  select(Village, `Cooperative/FICO` = Yes) %>%  
  left_join(cocoba_group_table %>% select(Village, `COCOBA or savings group` = Yes), by = "Village") %>%
  left_join(other_group_table %>% select(Village, `Other group` = Yes), by = "Village") %>%
  left_join(tnc_support_table %>% select(Village, `Group is TNC supported` = Yes), by = "Village") %>%
  left_join(group_helpfulness_table %>% select(Village, `Group is helpful` = Yes), by = "Village") 

# Calculate the overall average for all villages combined
total_row <- combined_table %>%
  summarise(
    Village = "Overall",
    `Cooperative/FICO` = mean(as.numeric(sub("%", "", `Cooperative/FICO`)) / 100, na.rm = TRUE) * 100,
    `COCOBA or savings group` = mean(as.numeric(sub("%", "", `COCOBA or savings group`)) / 100, na.rm = TRUE) * 100,
    `Other group` = mean(as.numeric(sub("%", "", `Other group`)) / 100, na.rm = TRUE) * 100,
    `Group is TNC supported` = mean(as.numeric(sub("%", "", `Group is TNC supported`)) / 100, na.rm = TRUE) * 100,
    `Group is helpful` = mean(as.numeric(sub("%", "", `Group is helpful`)) / 100, na.rm = TRUE) * 100) %>%
  mutate(
    `Cooperative/FICO` = paste0(round(`Cooperative/FICO`, 0)),
    `COCOBA or savings group` = paste0(round(`COCOBA or savings group`, 0)),
    `Other group` = paste0(round(`Other group`, 0)),
    `Group is TNC supported` = paste0(round(`Group is TNC supported`, 0)),
    `Group is helpful` = paste0(round(`Group is helpful`, 0)))

total_row <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Cooperative/FICO` = survey_mean(cooperative_fico == "YES", na.rm = TRUE) * 100,
    `COCOBA or savings group` = survey_mean(cocoba_savings == "YES", na.rm = TRUE) * 100,
    `Other group` = survey_mean(other_trading_group == "YES", na.rm = TRUE) * 100,
    `Group is TNC supported` = survey_mean(trading_tnc_supported == "YES", na.rm = TRUE) * 100,
    `Group is helpful` = survey_mean(trading_group_helpfulness == "YES", na.rm = TRUE) * 100) %>%
  mutate(
    `Cooperative/FICO` = paste0(round(`Cooperative/FICO`, 0)),
    `COCOBA or savings group` = paste0(round(`COCOBA or savings group`, 0)),
    `Other group` = paste0(round(`Other group`, 0)),
    `Group is TNC supported` = paste0(round(`Group is TNC supported`, 0)),
    `Group is helpful` = paste0(round(`Group is helpful`, 0))) %>% select(-contains("_se"))


# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)
colnames(combined_table) <- c("Village", "Cooperative/FICO (%)", "COCOBA or savings group (%)", "Other group (%)", "TNC supported groups (%)", "Group is helpful (%)")


add_lot_link(caption = 'Group membership of fish traders at village level (%)')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()

```

Fish trading groups face several challenges, including insufficient capital and limited access to loans, which compromise their ability to finance activities and expand operations (n = 7). Three respondents cited that delayed loan repayments create financial strain and disrupt group functionality. Inequitable distribution of group funds further compounds this issue, as leaders benefit disproportionately, leaving other members dissatisfied. A lack of skills, education, and entrepreneurial training further hampers group effectiveness (n = 4), while poor awareness among members about group activities weakens cohesion (n = 3). Additionally, small group sizes limit collective capacity, and irregular meetings and training sessions hinder progress and collaboration. These challenges collectively impact the efficiency and success of trader groups.

Changes to improve fish trading groups include securing access to loans from banks or other institutions to increase capital, receiving direct financial support or loans from the government and/or organizations for the purposes of expanding business ventures (n = 10). Furthermore, to improve groups, key changes highlighted by ten respondents include providing regular seminars and training on entrepreneurship and financial management, sharing experiences and knowledge with other groups within and outside the region, and educating members on the importance of being part of financial cooperatives (FICOs).


```{r, fig.cap='Do you think your current trading activities are likely to support your needs over the long term (next 5 - 10 years)?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
village_data_expanded <- tanganyika_survey %>%
  filter(!is.na(trading_long_term) & trading_long_term != "I DON'T KNOW") %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",  # Replace with your actual cluster 1 villages
    village %in% cluster_2_villages ~ "Cluster 2",  # Replace with your actual cluster 2 villages
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
village_data_design_cluster_1 <- village_data_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

village_data_design_cluster_2 <- village_data_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
village_data_cluster_1 <- village_data_design_cluster_1 %>%
  group_by(trading_long_term) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
village_data_cluster_2 <- village_data_design_cluster_2 %>%
  group_by(trading_long_term) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(village_data_combined, aes(x = fct_relevel(trading_long_term, "YES", "NO", "NOT SURE"), 
                                  y = proportion * 100, fill = trading_long_term)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, 
                    ymin = pmax(proportion_low, 0) * 100), 
                width = 0.2) +
  geom_text(aes(
    y = pmin(proportion_upp, 1) * 100 + 1, 
    label = paste0(round(proportion * 100, 0), "%")
  ), position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(
    legend.position = "none", 
    axis.text.x = element_text(angle = 45, hjust = 1), 
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    axis.text.y = element_blank(), 
    axis.title.y = element_blank()
  ) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster (2 rows)

```

Several households expressed satisfaction with their current income from fish trading, noting that it sufficiently meets their basic needs. Respondents (n = 3) also reported that their income from activities like fishing or business is adequate to support their families, and they feel secure in their ability to sustain their livelihoods over the next 5-10 years. Others (n = 2) highlighted the importance of diversifying their activities to ensure long-term stability. By engaging in multiple income-generating activities, they can meet the needs of their families. A small number of respondents emphasized that they are able to save from their income, ensuring that they can meet future needs. Some respondents provided additional factors that contribute to their outlook on long-term sustainability, such as good work practices, timing fishing activities well, and a general improvement in their current economic situation compared to the past (n = 5).

On the contrary, many respondents (n = 47) expressed concerns about their ability to sustain their livelihoods over the next 5-10 years due to low or insufficient income. Respondents noted that their earnings are not enough to meet their families' growing needs, and this lack of financial stability makes it difficult to plan for the future. Another significant number of respondents identified limited capital as a primary constraint to the sustainability of their current activities over the long term (n = 28). They highlighted that insufficient financial resources limit their ability to expand their businesses, invest in operations, and generate adequate returns to support their families. Some respondents highlighted various environmental and external challenges that hinder the sustainability of their current activities (n = 9). These include changes in natural resources, environmental degradation, and regulations that limit access to key livelihood resources like fish. Other concerns addressed broader economic challenges, business challenges in terms of seasonal variability, and the lack of reliable markets.

Unsustainable practices
 
Unsustainable practices in the fish trade include the use of illegal and harmful fishing gear such as poisoned nets, non-standard equipment, and filemayaa, which contribute to overfishing and depletion of fish stocks (n = 23). The practices are thought to threaten long-term sustainability by disrupting fish reproduction. Poor resource management, including the destruction of fish habitats and improper handling of fish remains, further exacerbates the problem (n = 3). Over-exploitation, such as harvesting immature fish and dependency solely on lake fisheries, limits resilience to stock depletion (n = 10). These practices, compounded by weak regulatory enforcement and exploitation by large companies and intermediaries, marginalize small-scale traders and undermine the viability of fish-based livelihoods.

In terms of financial sustainability, some households highlighted the instability of fish prices, with frequent and unpredictable price increases by fishermen (n = 12). The absence of a standardized pricing system renders the market unreliable, and large middlemen often exacerbate the situation by inflating prices. These fluctuations negatively affect the profitability of the fish trade, making it difficult for small-scale traders to plan and sustain their businesses, while also impacting the overall stability of the local fish market. Furthermore, a few households noted that conflicts between fishermen and Beach Management Units (BMUs) disrupt the reliability of fish availability (n = 3). Additionally, the lack of proper licensing often leads to bribery, further complicating the fishing process and contributing to unfair practices that affect the sustainability of fish trade.



</div>

## Livelihood Practices of Fish Processors

```{r, fig.cap='Processing form at village level (%)', fig.align='center', out.width = '90%'}
processing_form_expanded <- tanganyika_clean %>% select(hh_code, village, processing_form, stype, fpc) %>%
  separate_rows(processing_form, sep = "\\|") %>%
  mutate(processing_form = trimws(processing_form)) %>% drop_na()  

processing_form_expanded <- processing_form_expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

processing_form_design <- processing_form_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

processing_form_data <- processing_form_design %>%
  filter(!(village == "Ng'anga")) %>% # Ng'anga only contains one priamry sampling unit (PSU)
  group_by(village, cluster, processing_form) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- processing_form_design %>%
  filter(processing_form != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, processing_form) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
processing_form_data <- bind_rows(processing_form_data, overall_cluster_data)

processing_form_data <- processing_form_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(processing_form_data$village[processing_form_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(processing_form_data$village[processing_form_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
processing_form_data$processing_form <- factor(
  processing_form_data$processing_form,
  levels = processing_form_data %>%
    group_by(processing_form) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(processing_form))

ggplot(processing_form_data, aes(x = village, y = proportion * 100, group = processing_form, fill = processing_form)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  guides(fill = guide_legend(title = NULL, nrow = 1)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = function(labels) str_to_title(str_to_lower(labels))) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
        axis.text.x = element_text(size = 7), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), strip.text = element_blank(), legend.box = 
        "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_y_continuous(labels = label_percent(scale = 1))+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))

```


```{r, fig.cap='Processing equipment at village level (%)', fig.align='center', out.width = '90%'}
processing_equipment_expanded <- tanganyika_clean %>% select(hh_code, village, processing_equipment, stype, fpc) %>%
  separate_rows(processing_equipment, sep = "\\|") %>%
  mutate(processing_equipment = trimws(processing_equipment)) %>% drop_na()  

processing_equipment_expanded <- processing_equipment_expanded %>%
  mutate(cluster = case_when(village %in% cluster_1_villages ~ "Cluster 1", village %in% cluster_2_villages ~ "Cluster 2", TRUE ~ "Other"))

processing_equipment_design <- processing_equipment_expanded %>%
  as_survey_design(strata = stype, fpc = fpc)

processing_equipment_data <- processing_equipment_design %>%
   filter(!(village == "Ng'anga")) %>% # Ng'anga only contains one priamry sampling unit (PSU)
  group_by(village, cluster, processing_equipment) %>%
  summarise(proportion = survey_mean(vartype = "ci", na.rm = TRUE), total = survey_total(vartype = "ci", na.rm = TRUE), n = unweighted(n())) %>% ungroup()

overall_cluster_data <- processing_equipment_design %>%
  filter(processing_equipment != "I DO NOT WANT TO ANSWER") %>%
  group_by(cluster, processing_equipment) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  mutate(village = if_else(cluster == "Cluster 1", "Overall North", "Overall South"))

# Combine the overall cluster data with the original conflict_data
processing_equipment_data <- bind_rows(processing_equipment_data, overall_cluster_data)

processing_equipment_data <- processing_equipment_data %>%
  mutate(
    village = factor(
      village,
      levels = c(
        unique(processing_equipment_data$village[processing_equipment_data$cluster == "Cluster 1" & village != "Overall North"]),
        "Overall North",
        unique(processing_equipment_data$village[processing_equipment_data$cluster == "Cluster 2" & village != "Overall South"]),
        "Overall South")))

# Reorder treatment_method_dry based on average proportion for each method
processing_equipment_data$processing_equipment <- factor(
  processing_equipment_data$processing_equipment,
  levels = processing_equipment_data %>%
    group_by(processing_equipment) %>%
    summarise(avg_proportion = mean(proportion, na.rm = TRUE)) %>%
    arrange(desc(avg_proportion)) %>%
    pull(processing_equipment))

ggplot(processing_equipment_data, aes(x = village, y = proportion * 100, group = processing_equipment, fill = processing_equipment)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymax = pmin(proportion_upp * 100, 100), ymin = pmax(proportion_low * 100, 0)),
                position = position_dodge(preserve = "single", width = 0.95), width = 0.1) +
  guides(fill = guide_legend(title = NULL, nrow = 2)) +
  labs(x = NULL, y = NULL) +
  scale_fill_viridis(discrete = TRUE, option = "D", labels = function(labels) str_to_title(str_to_lower(labels))) +
  sea::theme_sea() + 
  theme(legend.position = "bottom",  legend.direction = "horizontal",  legend.justification = "center", 
        axis.text.x = element_text(size = 7), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), strip.text = element_blank(), legend.box = 
        "horizontal") + facet_wrap(~cluster, ncol = 1, scales = "free_x") +
  scale_y_continuous(labels = label_percent(scale = 1))+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10))
```


```{r, fig.cap='Seasonal processing of fish species over the past five years', fig.align='center', out.width = '90%'}
# Define target type variables
target_type_vars <- c("dagaa_process_season", "migebuka_process_season", "kungura_process_season", 
                      "ngege_process_season", "kuhe_process_season", "sangara_process_season")

# Pivot longer and clean Fish_Species names
target_type_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_vars), 
               names_to = "Fish_Species", 
               values_to = "Season") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_process_season", "") %>% str_to_title())

# Consolidate and clean `Season` values
target_type_long <- target_type_long %>%
  mutate(
    Season = case_when(
      str_detect(Season, "ALL SEASONS") & str_detect(Season, "RAINY SEASON") ~ "ALL SEASONS",
      str_detect(Season, "ALL SEASONS") & str_detect(Season, "DRY SEASON") ~ "ALL SEASONS",
      str_detect(Season, "RAINY SEASON") & str_detect(Season, "DRY SEASON") ~ "ALL SEASONS",
      Season == "I DON'T KNOW" ~ NA_character_,  
      TRUE ~ Season))

# Add cluster classification
target_type_long <- target_type_long %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",
    village %in% cluster_2_villages ~ "Cluster 2",
    TRUE ~ "Other"))

# Create survey design
strat_design <- target_type_long %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize by Fish_Species and Season for each cluster
aggregate_target_type <- strat_design %>%
  group_by(Fish_Species, Season, cluster) %>%
  summarise(mean_season = survey_mean(vartype = "ci", na.rm = TRUE), 
            n = unweighted(n())) %>% ungroup()



# Calculate percentages and handle totals
aggregate_target_type <- aggregate_target_type %>%
  filter(!is.na(Season) & Season != "NONE") %>% 
  group_by(Fish_Species, cluster) %>%
  mutate(
    total_season = sum(mean_season, na.rm = TRUE), # Total importance per Fish_Species
    mean_season_percent = (mean_season / total_season) * 100, # Relative percentage
    mean_season_percent_low = (mean_season_low / total_season) * 100,  # Lower bound of percentage
    mean_season_percent_upp = (mean_season_upp / total_season) * 100   # Upper bound of percentage
  ) %>%
  ungroup()


# Plotting with facet_wrap to separate by Cluster
ggplot(aggregate_target_type, aes(x = Fish_Species, y = mean_season_percent, group = Season, fill = Season)) +
  geom_bar(stat = "identity", position = position_dodge(preserve = "single"), width = 0.95) +
  geom_errorbar(aes(ymin = mean_season_percent_low, ymax = mean_season_percent_upp),
                position = position_dodge(width = 0.95), width = 0.2) +
  geom_text(aes(y = pmin(mean_season_percent_upp, 100) + 3, 
                label = scales::percent(mean_season_percent/100, accuracy = 1)),
            position = position_dodge(width = 0.95), size = 3) +
  labs(x = NULL, y = NULL) +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D", labels = function(labels) str_to_title(str_to_lower(labels))) +
  sea::theme_sea() + 
  theme(legend.position = "bottom", 
        legend.direction = "horizontal", 
        legend.justification = "center", 
        axis.text.x = element_text(size = 10),
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        strip.text = element_text(size = 12, face = "bold"),  # Customizing strip text size and style
        legend.box = "horizontal") + 
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  facet_wrap(~ cluster, nrow = 2, labeller = labeller(cluster = c("Cluster 1" = "Overall North", "Cluster 2" = "Overall South")))  # Custom labels for cluster

```


```{r, fig.cap='Sale prices (TSh) of fish species over the past five years for fish processors', fig.align='center', out.width = '90%'}
# Define target type variables for best values
target_type_best_vars <- c("dagaa_process_best", "migebuka_process_best", "kungura_process_best", 
                           "ngege_process_best", "kuhe_process_best", "sangara_process_best")

# Pivot longer and clean Fish_Species names for Best values
target_type_best_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_best_vars), 
               names_to = "Fish_Species", 
               values_to = "Best_Value") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_best", "") %>% str_to_title())

# Replace 97 with NA to treat as missing for Best values
target_type_best_long <- target_type_best_long %>%
  mutate(Best_Value = ifelse(Best_Value == 97, NA, Best_Value))

# Split data based on clusters for Best values
target_type_best_long_cluster_1 <- target_type_best_long %>%
  filter(village %in% cluster_1_villages)

target_type_best_long_cluster_2 <- target_type_best_long %>%
  filter(village %in% cluster_2_villages)

# Create survey design for Best values (Cluster 1)
strat_design_best_cluster_1 <- target_type_best_long_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Create survey design for Best values (Cluster 2)
strat_design_best_cluster_2 <- target_type_best_long_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize Best values for Cluster 1
aggregate_target_best_cluster_1 <- strat_design_best_cluster_1 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_best_value = survey_mean(Best_Value, vartype = "ci", na.rm = TRUE),
    mean_best_value_low = attr(mean_best_value, "ci")[1],
    mean_best_value_upp = attr(mean_best_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Summarize Best values for Cluster 2
aggregate_target_best_cluster_2 <- strat_design_best_cluster_2 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_best_value = survey_mean(Best_Value, vartype = "ci", na.rm = TRUE),
    mean_best_value_low = attr(mean_best_value, "ci")[1],
    mean_best_value_upp = attr(mean_best_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Combine Best values for both clusters
aggregate_target_best_combined <- bind_rows(
  aggregate_target_best_cluster_1 %>% mutate(cluster = "Cluster 1"),
  aggregate_target_best_cluster_2 %>% mutate(cluster = "Cluster 2")
)

# Define target type variables for worst values
target_type_worst_vars <- c("dagaa_process_worst", "migebuka_process_worst", "kungura_process_worst", 
                            "ngege_process_worst", "kuhe_process_worst", "sangara_process_worst")

# Pivot longer and clean Fish_Species names for Worst values
target_type_worst_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(target_type_worst_vars), 
               names_to = "Fish_Species", 
               values_to = "Worst_Value") %>%
  mutate(Fish_Species = str_replace(Fish_Species, "_worst", "") %>% str_to_title())

# Replace 97 with NA to treat as missing for Worst values
target_type_worst_long <- target_type_worst_long %>%
  mutate(Worst_Value = ifelse(Worst_Value == 97, NA, Worst_Value))

# Split data based on clusters for Worst values
target_type_worst_long_cluster_1 <- target_type_worst_long %>%
  filter(village %in% cluster_1_villages)

target_type_worst_long_cluster_2 <- target_type_worst_long %>%
  filter(village %in% cluster_2_villages)

# Create survey design for Worst values (Cluster 1)
strat_design_worst_cluster_1 <- target_type_worst_long_cluster_1 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Create survey design for Worst values (Cluster 2)
strat_design_worst_cluster_2 <- target_type_worst_long_cluster_2 %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize Worst values for Cluster 1
aggregate_target_worst_cluster_1 <- strat_design_worst_cluster_1 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_worst_value = survey_mean(Worst_Value, vartype = "ci", na.rm = TRUE),
    mean_worst_value_low = attr(mean_worst_value, "ci")[1],
    mean_worst_value_upp = attr(mean_worst_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Summarize Worst values for Cluster 2
aggregate_target_worst_cluster_2 <- strat_design_worst_cluster_2 %>%
  group_by(Fish_Species) %>%
  summarise(
    mean_worst_value = survey_mean(Worst_Value, vartype = "ci", na.rm = TRUE),
    mean_worst_value_low = attr(mean_worst_value, "ci")[1],
    mean_worst_value_upp = attr(mean_worst_value, "ci")[2],
    n = unweighted(n())
  ) %>% ungroup()

# Combine Worst values for both clusters
aggregate_target_worst_combined <- bind_rows(
  aggregate_target_worst_cluster_1 %>% mutate(cluster = "Cluster 1"),
  aggregate_target_worst_cluster_2 %>% mutate(cluster = "Cluster 2")
)

# Combine Best and Worst values into one dataframe
combined_target <- bind_rows(
  aggregate_target_best_combined %>%
    mutate(Value_Type = "Highest Sale Price", Value = mean_best_value) %>%
    select(-mean_best_value),  # remove `mean_best_value` after mutating
  aggregate_target_worst_combined %>%
    mutate(Value_Type = "Lowest Sale Price", Value = mean_worst_value) %>%
    select(-mean_worst_value))
  
combined_target$Fish_Species <- gsub("_process", "", combined_target$Fish_Species)

# Plotting the combined grouped bar chart with facets for each cluster and custom row titles
ggplot(combined_target, aes(x = Fish_Species, y = Value, fill = Value_Type)) +
  geom_bar(stat = "identity", position = "dodge", width = 0.75) +
  geom_errorbar(aes(ymin = ifelse(Value_Type == "Highest Sale Price", 
                                  mean_best_value_low, mean_worst_value_low), 
                    ymax = ifelse(Value_Type == "Highest Sale Price", 
                                  mean_best_value_upp, mean_worst_value_upp)), 
                position = position_dodge(0.75), width = 0.2) +
  labs(x = NULL, y = "Sale Price (TSh)") +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(legend.position = "bottom", 
        axis.text.x = element_text(size = 10), 
        strip.text = element_text(size = 12, face = "bold"),  # Set custom size and bold text for facet labels
        panel.grid.major = element_blank(),  
        panel.grid.minor = element_blank(),
        legend.box = "horizontal") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  scale_y_continuous(labels = scales::label_comma()) +
  facet_wrap(~ cluster, nrow = 2, labeller = labeller(cluster = c("Cluster 1" = "Overall North", "Cluster 2" = "Overall South")))

```

```{r, fig.cap='Satisfaction of fish processors', fig.align='center', out.width = '90%'}
# Define the mapping for satisfaction levels
satisfaction_mapping <- c(
  "1 VERY UNSATISFIED" = 1,
  "2 UNSATISFIED" = 2,
  "3 NEUTRAL" = 3,
  "4 SATISFIED" = 4,
  "5 VERY SATISFIED" = 5
)

satisfaction_columns <- c("satisfaction_process_skills", "process_tools_used", "process_productivity", 
                          "process_market_supply", "satisfaction_process_materials", "process_market", 
                          "process_income", "process_capital", "process_business_skills", 
                          "process_organization_support")

# Convert columns to numeric values
tanganyika_clean <- tanganyika_clean %>%
  mutate(across(all_of(satisfaction_columns), 
                ~ recode(., !!!satisfaction_mapping)))

# Pivot longer to reshape the data
satisfaction_long <- tanganyika_clean %>%
  pivot_longer(cols = all_of(satisfaction_columns), names_to = "Satisfaction_Area", values_to = "Satisfaction_Value")

# Filter out rows with NA values
satisfaction_long <- satisfaction_long %>%
  filter(!is.na(Satisfaction_Value))

# Add cluster classification
satisfaction_long <- satisfaction_long %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Overall North",  # Cluster 1
    village %in% cluster_2_villages ~ "Overall South",  # Cluster 2
    TRUE ~ "Other"
  ))

# Create survey design
strat_design_satisfaction <- satisfaction_long %>%
  as_survey_design(strata = stype, fpc = fpc)

# Summarize satisfaction values by cluster
aggregate_satisfaction <- strat_design_satisfaction %>%
  group_by(Satisfaction_Area, cluster) %>%
  summarise(
    mean_satisfaction_value = survey_mean(Satisfaction_Value, vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  ungroup()

# Plotting Satisfaction Values with clusters separated into rows
ggplot(aggregate_satisfaction, aes(
  x = reorder(Satisfaction_Area, -mean_satisfaction_value), 
  y = mean_satisfaction_value, 
  fill = Satisfaction_Area
)) +
  geom_bar(stat = "identity", width = 0.75) +
  labs(x = NULL, y = NULL) +
  guides(fill = guide_legend(title = NULL)) + 
  scale_fill_viridis(discrete = TRUE, option = "D") +
  sea::theme_sea() + 
  theme(
    legend.position = "none", 
    axis.text.x = element_text(angle = 45, hjust = 1), 
    strip.text = element_text(size = 12, face = "bold"),  # Bold, larger cluster titles
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),
    legend.box = "horizontal"
  ) +
  scale_y_continuous(
    limits = c(0, 5), 
    breaks = 1:5, 
    labels = c("VERY UNSATISFIED", "UNSATISFIED", "NEUTRAL", "SATISFIED", "VERY SATISFIED")
  ) +
  scale_x_discrete(labels = c(
    "Your skills", 
    "Your own business skills", 
    "The tools and\ntechnologies you use", 
    "Your productivity levels", 
    "Your access to\nmarket supply (inputs)", 
    "Your access to markets\nofftake/sales", 
    "Your income\nlevels generated", 
    "Your access to materials and\nequipment needed for processing", 
    "Your access to capital", 
    "The support you get from\ngroups or organizations"
  )) +
  facet_wrap(~ cluster, nrow = 2, scales = "free_y", strip.position = "top")

```

Fish processors face a range of challenges that compromise their businesses and livelihoods. Market-related issues such as fluctuating fish prices, lack of standardized pricing, limited markets for fish products, and interference from middlemen were stated as common (n = 19). Respondents also highlight health risks, which arise from prolonged smoke exposure, leading to respiratory issues, and injuries during processing (n = 13). Outdated equipment, frequent power outages, and limited access to energy resources (i.e. firewood) exacerbate processing difficulties, leading to spoilage of fish (n = 30). Rising input costs, poor infrastructure, and insufficient fish stock create further obstacles. Adverse weather conditions, financial constraints, and limited access to capital limit scalability, while quality control issues and fish spoilage result in financial losses. Additionally, theft during processing, lack of education on modern techniques, and bureaucratic hurdles such as securing permits and paying taxes further complicate their work. These challenges collectively impede the growth and sustainability of fish processing businesses.

Changes to improve fish processing

A major concern for respondents was the lack of sufficient capital or loans to enhance their fish processing operations (n = 37). The need for financial support was emphasized repeatedly, with many expressing that without adequate funds, they struggle to invest in necessary equipment required to expand their businesses. They requested access to microloans or financial assistance to improve their fish processing capacity and secure raw materials. Furthermore, access to modern and efficient tools for fish processing was another key request from respondents (n = 32). Many indicated that outdated or inadequate equipment hinders their ability to produce high-quality products and run efficient operations. Respondents highlighted the need for better processing tools, such as modern drying racks, cold storage, and improved fish preservation methods to reduce spoilage. Some respondents suggested that improved market access, both locally and internationally, would help reduce spoilage and increase profits (n = 7). They emphasized the importance of reliable market connections and the establishment of fair pricing systems to ensure that fish processing businesses remain sustainable. Another small group of respondents (n = 10) highlighted that training and education are crucial for improving their fish processing activities. They mentioned the need for learning new and modern ways to process fish, which would help them work more efficiently and produce better quality products. The establishment of a centralized location for fish trade, which could help streamline operations and reduce logistical challenges, was proposed by four processors. They also expressed interest in the availability of alternative energy sources, particularly for smoking fish, which could improve the efficiency of the processing process and reduce reliance on wood.


```{r}
summary_by_village <- tanganyika_survey %>%
  filter(!is.na(cooperative_fico_process) & cooperative_fico_process != "I DON'T KNOW") %>% 
  group_by(village, cooperative_fico_process) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)  # Weighted proportion
  ) %>%
  ungroup()

# Reshape the data to have "Yes" and "No" as columns
cooperative_table <- summary_by_village %>%
  select(village, cooperative_fico_process, proportion) %>%
  pivot_wider(names_from = cooperative_fico_process, values_from = proportion)

# Rename columns for clarity
colnames(cooperative_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
cooperative_table <- cooperative_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(cocoba_savings_process) & cocoba_savings_process != "I DON'T KNOW") %>% 
  group_by(village, cocoba_savings_process) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
cocoba_group_table <- summary_by_village %>%
  select(village, cocoba_savings_process, proportion) %>%
  pivot_wider(names_from = cocoba_savings_process, values_from = proportion)

# Rename columns for clarity
colnames(cocoba_group_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
cocoba_group_table <- cocoba_group_table %>%
  mutate(across(c("No", "Yes"),  ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(other_process_group) & other_process_group != "I DON'T KNOW") %>% 
  group_by(village, other_process_group) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
other_group_table <- summary_by_village %>%
  select(village, other_process_group, proportion) %>%
  pivot_wider(names_from = other_process_group, values_from = proportion)

# Rename columns for clarity
colnames(other_group_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
other_group_table <- other_group_table %>%
  mutate(across(c("No", "Yes"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(process_tnc_supported) & process_tnc_supported != "I DON'T KNOW") %>% 
  group_by(village, process_tnc_supported) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
tnc_support_table <- summary_by_village %>%
  select(village, process_tnc_supported, proportion) %>%
  pivot_wider(names_from = process_tnc_supported, values_from = proportion)

# Rename columns for clarity
colnames(tnc_support_table) <- c("Village", "Yes", "No")

# Format the proportion table values as percentages with one decimal point and add % sign
tnc_support_table <- tnc_support_table %>%
  mutate(across(c("Yes", "No"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

summary_by_village <- tanganyika_survey %>%
  filter(!is.na(process_group_helpfulness) & process_group_helpfulness != "I DON'T KNOW") %>% 
  group_by(village, process_group_helpfulness) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE)) %>% ungroup()

# Reshape the data to have "Yes" and "No" as columns
group_helpfulness_table <- summary_by_village %>%
  select(village, process_group_helpfulness, proportion) %>%
  pivot_wider(names_from = process_group_helpfulness, values_from = proportion)

# Rename columns for clarity
colnames(group_helpfulness_table) <- c("Village", "No", "Yes")

# Format the proportion table values as percentages with one decimal point and add % sign
group_helpfulness_table <- group_helpfulness_table %>%
  mutate(across(c("Yes", "No"), ~ if_else(is.na(.), "", paste0(round(. * 100, 0)))))

combined_table <- cooperative_table %>%
  select(Village, `Cooperative/FICO` = Yes) %>%  
  left_join(cocoba_group_table %>% select(Village, `COCOBA or savings group` = Yes), by = "Village") %>%
  left_join(other_group_table %>% select(Village, `Other group` = Yes), by = "Village") %>%
  left_join(tnc_support_table %>% select(Village, `Group is TNC supported` = Yes), by = "Village") %>%
  left_join(group_helpfulness_table %>% select(Village, `Group is helpful` = Yes), by = "Village") 

# Calculate the overall average for all villages combined
total_row <- combined_table %>%
  summarise(
    Village = "Overall",
    `Cooperative/FICO` = mean(as.numeric(sub("%", "", `Cooperative/FICO`)) / 100, na.rm = TRUE) * 100,
    `COCOBA or savings group` = mean(as.numeric(sub("%", "", `COCOBA or savings group`)) / 100, na.rm = TRUE) * 100,
    `Other group` = mean(as.numeric(sub("%", "", `Other group`)) / 100, na.rm = TRUE) * 100,
    `Group is TNC supported` = mean(as.numeric(sub("%", "", `Group is TNC supported`)) / 100, na.rm = TRUE) * 100,
    `Group is helpful` = mean(as.numeric(sub("%", "", `Group is helpful`)) / 100, na.rm = TRUE) * 100) %>%
  mutate(
    `Cooperative/FICO` = paste0(round(`Cooperative/FICO`, 0)),
    `COCOBA or savings group` = paste0(round(`COCOBA or savings group`, 0)),
    `Other group` = paste0(round(`Other group`, 0)),
    `Group is TNC supported` = paste0(round(`Group is TNC supported`, 0)),
    `Group is helpful` = paste0(round(`Group is helpful`, 0)))

total_row <- tanganyika_survey %>%
  summarise(
    Village = "Overall",
    `Cooperative/FICO` = survey_mean(cooperative_fico_process == "YES", na.rm = TRUE) * 100,
    `COCOBA or savings group` = survey_mean(cocoba_savings_process == "YES", na.rm = TRUE) * 100,
    `Other group` = survey_mean(other_process_group == "YES", na.rm = TRUE) * 100,
    `Group is TNC supported` = survey_mean(process_tnc_supported == "YES", na.rm = TRUE) * 100,
    `Group is helpful` = survey_mean(process_group_helpfulness == "YES", na.rm = TRUE) * 100) %>%
  mutate(
    `Cooperative/FICO` = paste0(round(`Cooperative/FICO`, 0)),
    `COCOBA or savings group` = paste0(round(`COCOBA or savings group`, 0)),
    `Other group` = paste0(round(`Other group`, 0)),
    `Group is TNC supported` = paste0(round(`Group is TNC supported`, 0)),
    `Group is helpful` = paste0(round(`Group is helpful`, 0))) %>% select(-contains("_se"))

# Add the "Total" row to the combined table
combined_table <- bind_rows(combined_table, total_row)
colnames(combined_table) <- c("Village", "Cooperative/FICO (%)", "COCOBA or savings group (%)", "Other group (%)", "TNC supported groups (%)", "Group is helpful (%)")

add_lot_link(caption = 'Group membership of fish processors at village level (%)')

# Add the flextable with a caption
combined_table %>%
  sea::sea_table(
    dark_color = sea_colors("gunmetal"),
    pale_color = sea_colors("grey"),
    third_color = "white"
  ) %>%
  flextable::autofit()
 
```

Challenges pertaining to fish processing groups pertained to financial hardships. Six respondents expressed insufficient group funds, limited capital, and reliance on member contributions as a primary challenge. Financial instability restricts the processing group’s ability to scale up operations, invest in new ventures, or support members adequately during periods of economic strain or fishing bans. A further three households indicated that challenges included low meeting attendance during gatherings, a lack of alternative income-generating activities, and limited education among members. These factors contribute to the group’s inability to sustain operations during difficult periods (i.e. fishing bans) when member contributions are also reduced.

In order to improve conditions of the fish processing groups, respondents emphasized the importance of accessing loans and increasing group capital (n = 6). They noted that the group currently relies on member contributions, which limits its ability to provide sufficient funds for investments, loans, and growth opportunities. Financial empowerment is seen as critical for supporting group sustainability and member livelihoods. A further two respondents identified training as a key improvement area. Skills development could strengthen management, promote better decision-making, and equip members with strategies to improve group operations. One household member proposed seeking external partnerships and funding to ensure group sustainability. They felt collaborations with organizations could reduce reliance on internal contributions and provide additional resources to grow the group. External support would also help stabilize finances and introduce new opportunities for innovation and expansion of group activities.


```{r, fig.cap='Do you think your current processing activities are likely to support your needs over the long term (next 5 - 10 years)?', fig.align='center', out.width = '90%'}
# Expand the data with cluster classification
village_data_expanded <- tanganyika_survey %>%
  filter(!is.na(process_long_term)) %>%
  mutate(cluster = case_when(
    village %in% cluster_1_villages ~ "Cluster 1",  # Replace with your actual cluster 1 villages
    village %in% cluster_2_villages ~ "Cluster 2",  # Replace with your actual cluster 2 villages
    TRUE ~ "Other"
  ))

# Create survey designs for each cluster
village_data_design_cluster_1 <- village_data_expanded %>%
  filter(cluster == "Cluster 1") %>%
  as_survey_design()

village_data_design_cluster_2 <- village_data_expanded %>%
  filter(cluster == "Cluster 2") %>%
  as_survey_design()

# Summarise for Cluster 1
village_data_cluster_1 <- village_data_design_cluster_1 %>%
  group_by(process_long_term) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Summarise for Cluster 2
village_data_cluster_2 <- village_data_design_cluster_2 %>%
  group_by(process_long_term) %>%
  summarise(
    proportion = survey_mean(vartype = "ci", na.rm = TRUE),
    total = survey_total(vartype = "ci", na.rm = TRUE),
    n = unweighted(n())
  ) %>%
  drop_na()

# Combine the two clusters' data
village_data_combined <- bind_rows(
  village_data_cluster_1 %>% mutate(cluster = "Overall North"),
  village_data_cluster_2 %>% mutate(cluster = "Overall South")
)

# Create the plot with two rows for clusters
ggplot(village_data_combined, aes(x = fct_relevel(process_long_term, "YES", "NO", "NOT SURE"), 
                                  y = proportion * 100, fill = process_long_term)) +
  geom_bar(stat = "identity", width = 0.8) +
  geom_errorbar(aes(ymax = pmin(proportion_upp, 1) * 100, 
                    ymin = pmax(proportion_low, 0) * 100), 
                width = 0.2) +
  geom_text(aes(
    y = pmin(proportion_upp, 1) * 100 + 1, 
    label = paste0(round(proportion * 100, 0), "%")
  ), position = position_dodge(width = 0.95), vjust = -0.5, size = 3) +
  guides(fill = guide_legend(title = NULL)) + 
  labs(x = NULL, y = NULL) +  
  sea::scale_fill_sea_discrete(4) +
  sea::theme_sea() + 
  theme(
    legend.position = "none", 
    axis.text.x = element_text(angle = 45, hjust = 1), 
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    axis.text.y = element_blank(), 
    axis.title.y = element_blank()
  ) +
  scale_y_continuous(labels = label_percent(scale = 1)) +
  scale_x_discrete(labels = c("Yes", "No", "Not Sure")) +
  facet_wrap(~ cluster, nrow = 2)  # Separate plots for each cluster (2 rows)

```

Few households felt their current activities were likely to support their long-term needs as they have a strong production capacity and the ability to access markets in a timely manner, which they believe will enable them to engage in activities sustainably in future. Others reported that their current activities are likely to support their long-term needs because they provide sufficient income to meet their family's basic needs, ensuring financial stability. Some stated that sustainable fishing practices would enhance processing activities, and they anticipated that their business would grow significantly, enabling them to generate sufficient income in the future.

Many household felt that their income will remain insufficient to cover basic needs, including family requirements, and that the limited capital prevents them from reaching their goals or continuing their businesses (n = 52). They also expressed concerns about the instability of their earnings, particularly in times of drought or market fluctuations. Other concerns regarding long-term sustainability of their processing practices pertained to declines in production levels, reductions in fish stock due to overfishing and illegal fishing practices, and constraints related to the seasonal nature of the business, which cannot sustain them throughout the year. These respondents also mentioned that the fish processing industry is unpredictable, with fluctuating availability leading to inconsistent business performance. 

Processing unsustainable practices

Fish processors indicated that they encounter various unsustainable practices that undermine their livelihoods and environment. Most significantly, the purchase of fish caught using illegal fishing methods result in the spoilage of fish, which are often unfit for processing (n = 21). Illegal fishing, particularly targeting small fish, depletes fish stocks and disrupts breeding, negatively affecting the processing supply chain. Unhygienic and unsustainable processing practices contribute to environmental degradation, by means of tree cutting for firewood and improper disposal of fish waste into water bodies (n = 20). Market practices, including reliance on middlemen, fluctuating fish prices, and insufficient customer engagement compromise the financial sustainability of processing (n = 11). Collectively, these practices threaten the sustainability of the fish processing industry.


</div>

<!-- putting bibliography before appendix -->
<div id="refs">
## Bibliography
